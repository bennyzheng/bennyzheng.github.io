<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思考与记录</title>
  <subtitle>有时候停下来思考，然后拿起笔记录。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bennyzheng.github.io/"/>
  <updated>2016-11-26T03:17:44.000Z</updated>
  <id>https://bennyzheng.github.io/</id>
  
  <author>
    <name>benny zheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器事件循环以及多线程</title>
    <link href="https://bennyzheng.github.io/archivers/2016/11/event-loop-and-multi-thread/"/>
    <id>https://bennyzheng.github.io/archivers/2016/11/event-loop-and-multi-thread/</id>
    <published>2016-11-25T18:33:32.000Z</published>
    <updated>2016-11-26T03:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript在浏览器中一直都是以单线程的方式运行，这意味着它同一时间只能干一件事，前端们不用担心你在读完一个变量的时候该变量马上被另一个线程修改而导致后续计算变得不准确，也不用担心对一个DOM节点做修改操作的时候突然它被删除。支持多线程的语言都有一个东西叫线程锁，但是Javascript作为操作HTML页面的脚本语言它应该足够简单，所以单线程是最合适的，但同样有方法实现多线程以提高系统资源利用率。<br><a id="more"></a></p>
<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>首先了解一下什么叫进程。进程就是一个应用程序在内存中的实例，一个CPU核心只能在同一时间处理一个进程的工作，操作系统同时在跑的应用程序当然不可能只有一个，所以操作系统就不停地把CPU资源交给其中一个进程，而其它没排到队的进程则进入沉睡状态。许多时候为了更好的利用起多核CPU的优势，一个进程往往会把自己fork成多个进程，让应用程序的工作能够同时在多个CPU上跑起来以达到利用更多CPU资源提高性能的目的，比如Node.js就是这么干的。</p>
<p>线程是轻量版的进程，一个进程可以拥有多个线程，线程也是CPU资源调度的最小单位，但线程与线程可以共享进程的公用资源。在超线程技术发明之后，多核多线程CPU再配上相应的操作系统、软件可以实现多个线程利用多个CPU核心的资源。</p>
<p>上边仅是简单地讲一下进程和线程，我对这方面并不擅长，或许有什么理解上的错误，但是GUI界面的应用程序一般都是对UI的交互交给一个线程处理，其它线程用于做计算。这样，其它线程在计算的同时不会阻塞了UI线程的运行，界面也就不会卡顿。</p>
<p>可能有人会提起setTimeout，说当我设置两个定时器，都是在1秒后执行，那么它们不就同时执行了吗？看起来像是多线程了，事实上二者不可能同时执行。使用setTimeout注册过的函数并不保证非常准时地执行，可能会延后一点时间执行，两个注册在定时器里的函数也是先后执行的，只有一个执行完了才会执行另一个。</p>
<p>这个先后关系是通过一个叫事件循环的东西来做调度的，页面上所有任务都会被放到一个先进先出的队列中进行排队，事件循环机制会从队列头取出一个任务执行，该任务完成后再取下一个任务执行。如果一个任务有大量的运算或费时的同步操作（比如同步ajax）将会导致下一个任务一直处于等待状态。</p>
<p>我们可以做一个实验：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html &gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">console</span>.time(<span class="string">"begin"</span>);</div><div class="line"></div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"begin"</span>);</div><div class="line">        &#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">            $.ajax(&#123;</div><div class="line">                <span class="attr">url</span>: <span class="string">"./test.html"</span>,</div><div class="line">                <span class="attr">async</span>: <span class="literal">false</span>,</div><div class="line">                <span class="attr">method</span>: <span class="string">"get"</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这个示例中，一开始就注册了个函数在一秒后输出从开始注册到开始执行的时间差，随后再调用ajax同步请求当前页面（./text.html）一千次，在我的机子上输出了”begin: 1.74e+03ms”，也就是事实上1740ms后才执行了setTimeout的回调函数。这是因为同步操作导致事件循环长时间耗在请求代码的任务上而没有开始下一个注册的任务。</p>
<p>有一个非常有用的技巧，如果有一个不重要也不影响当前流程走向的任务，可以使用setTimeout(fn, 0)来执行。虽然0表示马上执行，但事实上事件循环并不会马上执行它，而是会将它插入任务队列，这样子更重要的任务就会被先执行了，比如界面的渲染。</p>
<h1 id="初识Worker"><a href="#初识Worker" class="headerlink" title="初识Worker"></a>初识Worker</h1><p>尽管在浏览器中脚本确实是以单线程的方式运行的，但考虑到可能会有大量数据计算之类的耗时操作，IE10以上版本以及其它标准浏览器都已经支持了Web Worker，它实现了Javascript在浏览器中多线程的需求，在一个Worker中不管做什么同步操作都不会影响到页面的操作，也不会导致页面卡顿（当然，你的硬件很差这个就回天无力了，毕竟系统资源就那么多）。</p>
<p>先来看一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time(<span class="string">"timeout"</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"timeout"</span>);</div><div class="line">&#125;, <span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.time(<span class="string">"concat"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</div><div class="line">    str = str + <span class="string">"abc"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"concat"</span>);</div></pre></td></tr></table></figure>
<p>在我机子上执行结果是：</p>
<p>concat: 609ms<br>timeout: 674ms</p>
<p>由于现在我们将字符拼接的代码放入Worker中执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time(<span class="string">"worker"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</div><div class="line">    str = str + <span class="string">"abc"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"worker"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">"./worker.js"</span>);</div><div class="line"><span class="built_in">console</span>.time(<span class="string">"timeout"</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"timeout"</span>);</div><div class="line">&#125;, <span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.time(<span class="string">"worker"</span>);</div></pre></td></tr></table></figure>
<p>很惊人地结果：</p>
<p>timeout: 100ms<br>worker: 109ms</p>
<p>虽然并不是每次都一样，但基本上timeout都是100ms，而worker都是100ms出头，也就是说从性能上看提高幅度非常大。为什么同样的代码在页面上执行需要609ms，而在worker中却只需要109ms？按我的理解是浏览器主页面线程的脚本是跟整个页面的各种任务在抢资源，而worker则是另起一线程独占了一份独立的CPU资源，自然运行速度就快很多了。</p>
<p>在MDN上关于Worker的介绍有一段文字很自信地拍着胸口向使用者们保证Worker的线程安全问题：</p>
<blockquote><p>Worker 接口会生成真正的操作系统级别的线程，如果你不太小心，那么并发(concurrency)会对你的代码产生有趣的影响。然而，对于 web worker 来说，与其他线程的通信点会被很小心的控制，这意味着你很难引起并发问题。你没有办法去访问非线程安全的组件或者是 DOM，此外你还需要通过序列化对象来与线程交互特定的数据。所以你要是不费点劲儿，还真搞不出错误来。</p>
<footer><strong>MDN</strong><cite><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">使用 Web Workers</a></cite></footer></blockquote>
<p>Worker在运行期间与主线程几乎是完全分开的，二者无法直接共享数据，Worker也不能直接操作页面的DOM节点，简单来说不能把它当面浏览器中的普通脚本，它的环境更加纯净。</p>
<p>Worker可以做以下几件事：</p>
<ul>
<li>与主线程互相通讯</li>
<li>使用XMLHttpRequest发起请求</li>
<li>使用定时器</li>
</ul>
<p>除此之外，Worker同时能够使用许多函数以及小量的限制版对象，比如location以及navigator。这方面的信息可以查阅《<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers 来自MDN" target="_blank" rel="external">Worker支持的函数</a>》。</p>
<h1 id="使用Worker"><a href="#使用Worker" class="headerlink" title="使用Worker"></a>使用Worker</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Worker初始化非常简单，直接使用new关键词新建一个实例，传入新线程代码所在的脚本文件路径(注意：<strong>必须遵守同源策略，但Worker内部使用importScripts函数加载的代码则不需要遵守，你可以加载CDN上的jquery库</strong>)，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">"./test.js"</span>);</div></pre></td></tr></table></figure>
<p>事实上为了减少http请求，除了IE之外的浏览器还支持用URL对象当参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/code"</span> <span class="attr">id</span>=<span class="string">"worker-code"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">console</span>.time(<span class="string">"inline worker"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> str = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</div><div class="line">        str = str + <span class="string">"abc"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"inline worker"</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> code = <span class="built_in">document</span>.getElementById(<span class="string">"worker-code"</span>).innerHTML;</div><div class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(<span class="built_in">Array</span>.from(code), &#123; <span class="attr">type</span>: <span class="string">"text/javascript"</span> &#125;);</div><div class="line">    <span class="keyword">var</span> url = URL.createObjectURL(blob);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</div><div class="line">    <span class="built_in">console</span>.time(<span class="string">"timeout"</span>);</div><div class="line"></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">"timeout"</span>);</div><div class="line">    &#125;, <span class="number">100</span>);</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.time(<span class="string">"worker"</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在我的机子上，运行结果是：</p>
<p>timeout: 101ms<br>inline worker: 108ms</p>
<p>其实跟前边的运行结果没什么区别，本来timeout就有可能延时执行。我个人是比较推荐内嵌worker代码在页面或者放入javascript代码内执行（很简单啊，写个函数然后toString一下就得到它的代码了…），这样可以节省http请求，加载Worker的脚本文件也是要花时间的，尽管浏览器很聪明地帮我们隐藏了一切，你可以把它当成瞬间就加载完一般使用，这个后边会讲。</p>
<h2 id="线程通讯"><a href="#线程通讯" class="headerlink" title="线程通讯"></a>线程通讯</h2><p>Worker线程可以与主线程通讯，这主要是通过postMessage以及message事件来实现，并且可以传递序列化后的数据给对方：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/code"</span> <span class="attr">id</span>=<span class="string">"worker-code"</span>&gt;</span><span class="javascript"></span></div><div class="line">    addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="comment">// ev是一个message对象，可以用这种方法看它的结构</span></div><div class="line">        <span class="comment">// console.dir(ev);</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"worker accept: %s"</span>, ev.data);</div><div class="line">        postMessage(<span class="string">"hello master"</span>);</div><div class="line">    &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> code = <span class="built_in">document</span>.getElementById(<span class="string">"worker-code"</span>).innerHTML;</div><div class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(<span class="built_in">Array</span>.from(code), &#123; <span class="attr">type</span>: <span class="string">"text/javascript"</span> &#125;);</div><div class="line">    <span class="keyword">var</span> url = URL.createObjectURL(blob);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</div><div class="line"></div><div class="line">    worker.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"master accept: %s"</span>, ev.data);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    worker.postMessage(<span class="string">"hello worker"</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在主线程中首先创建了一个Worker，并为该Worker绑定了message事件用于响应来自Worker post过来的消息。Worker同样使用绑定了message事件，用于接收来自主线程的消息并随后向主线程发送消息，这就是最简单的通讯方式。这段代码在我的机子上运行结果如下：</p>
<p>worker accept: hello worker<br>master accept: hello master</p>
<p>一般来说线程之间无法互相post对象，只能post可序列化的数据，比如将示例中的代码稍改一下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/code"</span> <span class="attr">id</span>=<span class="string">"worker-code"</span>&gt;</span><span class="javascript"></span></div><div class="line">    addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="comment">// ev是一个message对象，可以用这种方法看它的结构</span></div><div class="line">        <span class="comment">// console.dir(ev);</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"worker accept: %s, type: %s"</span>);</div><div class="line">        postMessage(<span class="string">"hello master"</span>);</div><div class="line">    &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> code = <span class="built_in">document</span>.getElementById(<span class="string">"worker-code"</span>).innerHTML;</div><div class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(<span class="built_in">Array</span>.from(code), &#123; <span class="attr">type</span>: <span class="string">"text/javascript"</span> &#125;);</div><div class="line">    <span class="keyword">var</span> url = URL.createObjectURL(blob);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</div><div class="line"></div><div class="line">    worker.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"master accept: %s"</span>, ev.data);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    worker.postMessage(<span class="built_in">document</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>该示例将document对象post过去，然后报了这样的异常：Uncaught DOMException: Failed to execute ‘postMessage’ on ‘Worker’: An object could not be cloned.意思是说document无法被复制一个副本用于post。</p>
<p>没错，postMessage方法在传递数据的时候是复制一个副本而不是直接将内容本身送过去，类似于函数传递参数，函数的参数就相当于函数的局部变量，它是外部传递进来的值的一个副本，二者毫无关系互不影响。而document对象却无法复制（只要是DOM对象皆如此），无法传递对象的引用。</p>
<p>或许现在你会马上尝试传递一个普通的Javascript对象过去，可以的，一点问题都没有！因为普通的对象依然是可以通过JSON.stringify(obj)的方式转换成json字符串。我尝试过，确实非常方便，在Worker内部接收到的自动帮我们反序列化成一个跟原来一模一样的对象。要注意的是：<strong>该对象依然是原来对象的一个副本，在Worker中进行修改并不会导致主线程的对象发生改变！</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/code"</span> <span class="attr">id</span>=<span class="string">"worker-code"</span>&gt;</span><span class="javascript"></span></div><div class="line">    addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = ev.data;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"worker: %s"</span>, <span class="built_in">JSON</span>.stringify(obj));</div><div class="line">        ev.data.value = <span class="string">"world"</span>;</div><div class="line">        <span class="comment">// &#123; "value": "world" &#125; 值已经改变</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"worker: %s"</span>, <span class="built_in">JSON</span>.stringify(obj));</div><div class="line">        postMessage(<span class="string">"ok!"</span>)</div><div class="line">    &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> code = <span class="built_in">document</span>.getElementById(<span class="string">"worker-code"</span>).innerHTML;</div><div class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(<span class="built_in">Array</span>.from(code), &#123; <span class="attr">type</span>: <span class="string">"text/javascript"</span> &#125;);</div><div class="line">    <span class="keyword">var</span> url = URL.createObjectURL(blob);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</div><div class="line">    <span class="keyword">var</span> obj = &#123; <span class="attr">value</span>: <span class="string">"hello"</span> &#125;;</div><div class="line"></div><div class="line">    worker.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="comment">// 检查一下外部的obj</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"master: %s"</span>, <span class="built_in">JSON</span>.stringify(obj));</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    worker.postMessage(obj);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这就是输出结果，符合我上边的说法：</p>
<p>worker: {“value”:”hello”}<br>worker: {“value”:”world”}<br>master: {“value”:”hello”}</p>
<p>但这种做法并不能让我们比较满意，如果需要传输一段文件内容，那么这个序列化、复制、反序列化的过程将会比较耗时。还好，Worker提供了一种方式可以让我们某些类型的对象直接传递引用过去，但出于线程安全考虑，该对象在原来的上下文中会消失！也就是如果主线程将对象转让给Worker之后，主线程就访问不到该对象了。根据文档中描述，现阶段仅有MessagePort以及ArrayBuffer两种对象可以用于转让。</p>
<p>postMessage方法其实拥有两个参数，第二个参数是一个可选的数组，用于放置转让对象列表：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/code"</span> <span class="attr">id</span>=<span class="string">"worker-code"</span>&gt;</span><span class="javascript"></span></div><div class="line">    addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> typeArray = ev.data;</div><div class="line">        <span class="comment">// 1, 2, 3</span></div><div class="line">        <span class="built_in">console</span>.log(typeArray.toString());</div><div class="line">        postMessage(<span class="string">"ok"</span>);</div><div class="line">    &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> code = <span class="built_in">document</span>.getElementById(<span class="string">"worker-code"</span>).innerHTML;</div><div class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob(<span class="built_in">Array</span>.from(code), &#123; <span class="attr">type</span>: <span class="string">"text/javascript"</span> &#125;);</div><div class="line">    <span class="keyword">var</span> url = URL.createObjectURL(blob);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(url);</div><div class="line">    <span class="keyword">var</span> typeArray = <span class="keyword">new</span> <span class="built_in">Int8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line">    worker.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="comment">// Int8Array[0]</span></div><div class="line">        <span class="built_in">console</span>.dir(typeArray);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    worker.postMessage(typeArray, [typeArray.buffer]);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>示例将typeArray传递给Worker，它将被序列化。但在postMessage时却将typeArray的buffer列在转让列表中，要求该对象直接进行转让，也就是说在Worker中复制的typeArray使用的ArrayBuffer对象其实就是主线程中的typeArray使用的ArrayBuffer，它并没有经过复制。在Worker得到typeArray之后，重新发了个消息通知主线程，这时候主线程再来做检查，外部的typeArray还在（因为仅是复制了一份），但它的buffer却不见了，缓冲区变成0字节。</p>
<p>这里必须强调一点，转让列表中的对象必须是postMessage第一个参数的本身或者一部份，如果与它毫无关联那么在Worker内部无法得到它。</p>
<h2 id="停止Worker"><a href="#停止Worker" class="headerlink" title="停止Worker"></a>停止Worker</h2><p>想要将一个Worker停止非常简单，worker对象提供了terminate方法，而Worker内部则可以调用close方法关闭本线程。</p>
<h1 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h1><p>Worker允许加载一个同源的js文件作为它的执行代码，同时在Worker内部可以使用importScripts函数无限制地跨域加载js文件。由于加载js文件是需要时间的，在执行过程中它们是同步的还是异步的还需要进行实验：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">sleep(<span class="number">1</span>);</div><div class="line">header(<span class="string">'Content-Type: application/javascript'</span>);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">console.log(<span class="string">"worker load: %d"</span>, <span class="keyword">new</span> Date().getTime());</div><div class="line"></div><div class="line">addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span><span class="params">(ev)</span> </span>&#123;</div><div class="line">    console.log(<span class="string">"worker accept: %s, time is %d"</span>, ev.data, <span class="keyword">new</span> Date().getTime());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"worker create: %d"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</div><div class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">"./worker.php?t="</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</div><div class="line">worker.postMessage(<span class="string">"here?"</span>)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"master send: %d"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</div></pre></td></tr></table></figure>
<p>worker.php文件先来了个sleep(1)睡眠了1秒才开始返回数据，也就是说Worker是至少1秒后才开始工作。而主线程在建立Worker之后马上发送一句”here?”并输出时间，现在看一下运行结果，令人惊讶：</p>
<p>worker create: 1480097663629<br>master send: 1480097663631<br>worker load: 1480097664656<br>worker accept: here?, time is 1480097664660</p>
<p>“worker create”与”master send”之间的时间间隔是2ms，也就是说几乎同时执行，证明建立一个Worker并不是同步操作。在1000ms后控制台出现”worker load”，证明Worker真的是1秒后才开始工作，但后边的”worker accept”却表示它接收到了”here?”。按常理来说消息是在Worker运行前一秒发的，当Worker开始运行时消息早已经丢失，因为在发送时没人接收，但事实上并非如此。</p>
<p>现在再将php代码稍改改看看运行结果：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">sleep(<span class="number">1</span>);</div><div class="line">header(<span class="string">'Content-Type: application/javascript'</span>);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">console.log(<span class="string">"worker load: %d"</span>, <span class="keyword">new</span> Date().getTime());</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">    addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span><span class="params">(ev)</span> </span>&#123;</div><div class="line">        console.log(<span class="string">"worker accept: %s, time is %d"</span>, ev.data, <span class="keyword">new</span> Date().getTime());</div><div class="line">    &#125;);</div><div class="line">&#125;, <span class="number">100</span>);</div></pre></td></tr></table></figure>
<p>我将message事件的绑定放到setTimeout之中，也就是0.1秒后才绑事件，运行结果如下：</p>
<p>worker create: 1480098216641<br>master send: 1480098216643<br>worker load: 1480098217667</p>
<p>这次Worker真的接收不到未执行前发送的消息了。由此可见Worker的执行代码加载确实是异步的，在Worker加载期间主线程发送的消息都会被暂存起来，直到Worker开始执行并且绑定了message事件，浏览器才会将保存起来的消息真的发送过去，但是在Worker脚本执行完之后还没碰上事件绑定，消息就真的被抛弃了，哪怕你在某个时刻终于想起要绑定message事件都无法收到消息。浏览器在这方面封装得非常棒，至少我们不需要确保Worker绑定事件后才开始发送消息，唯一需要注意的是必须在Worker的全局作用域下直接绑个message事件而不能在某个异步操作之后再绑。</p>
<p>需要考虑执行顺序的还有Worker内部的importScripts数，它能够加载一个js文件在当前作用域下执行，但这个我们无需试验，因为MDN上说得非常清楚：</p>
<blockquote><p>注意： 脚本的下载顺序不固定，但执行时会按照你将文件名传入到 importScripts() 中的顺序。这是同步完成的；直到所有脚本都下载并运行完毕， importScripts() 才会返回。</p>
<footer><strong>MDN</strong><cite><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="external">使用 Web Workers</a></cite></footer></blockquote>
<p>也就是说importScripts是一个同步操作，它允许你一次传入多个文件路径导入并执行，虽然这些文件由于网络原因加载完成的时间不一样，但Worker会保证它们在全部加载完之后再执行，而且执行顺序跟参数的顺序一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">importScripts(<span class="string">"a.js"</span>, <span class="string">"b.js"</span>, <span class="string">"c.js"</span>);</div><div class="line"><span class="comment">// other code</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript在浏览器中一直都是以单线程的方式运行，这意味着它同一时间只能干一件事，前端们不用担心你在读完一个变量的时候该变量马上被另一个线程修改而导致后续计算变得不准确，也不用担心对一个DOM节点做修改操作的时候突然它被删除。支持多线程的语言都有一个东西叫线程锁，但是Javascript作为操作HTML页面的脚本语言它应该足够简单，所以单线程是最合适的，但同样有方法实现多线程以提高系统资源利用率。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://bennyzheng.github.io/categories/javascript/"/>
    
    
      <category term="event-loop" scheme="https://bennyzheng.github.io/tags/event-loop/"/>
    
      <category term="multi-thread" scheme="https://bennyzheng.github.io/tags/multi-thread/"/>
    
      <category term="web-worker" scheme="https://bennyzheng.github.io/tags/web-worker/"/>
    
  </entry>
  
  <entry>
    <title>数据存储方式 - endian</title>
    <link href="https://bennyzheng.github.io/archivers/2016/11/endian/"/>
    <id>https://bennyzheng.github.io/archivers/2016/11/endian/</id>
    <published>2016-11-22T16:00:00.000Z</published>
    <updated>2016-12-02T08:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>现有两大CPU派系PowerPC以及Intel在数据存储上存在着差异，二者分别采用了big-endian以及little-endian方式保存一个多字节的数字。原本我从来没关注过这个问题，现有的工具已经把它们的差异封装得很好了，直到我最近尝试去操作了一些二进制数据才意识到我需要关注一下。<br><a id="more"></a><br>数据在内存中是以二进制方式存储的，一个字节可以存储一个8位的整型，有符号整型可以存储-128至127，而无符号整型可以存储0-255。无符号整型255写成二进制以及十六进制形式是：</p>
<p>1111 1111<br>F    F</p>
<p>也就是范围用16进制表示是0x00至0xff，我们后边就用两个16进制的字符来表示一个字节的值。</p>
<p>网上有篇文章讲解endian，使用了0x12345678作为例子，我觉得非常好，事实上我也是参考了那篇文章，并把自己的理解写在这。这个数字是8个16进制字符，按2个字符1个字节算其实它就是一个32位的无符号整型，即4个字节，按照我们的书写习惯它应该是这么写的：</p>
<p><img src="/images/2016/11/endian-1.png" alt="big-endian"></p>
<p>这种写法被称为big-endian，它的存储原则是高位优先，从高位字节到低位字节按顺序写到相邻的四个字节中，PowerPC采用的正是这种方式。</p>
<p>Intel采用是little-endian，它的存储原则是低位优先，从低位字节到高拉字节按顺序写到相邻的四个字节中，也就是big-endian反过来：</p>
<p><img src="/images/2016/11/endian-2.png" alt="little-endian"></p>
<p>二者到底有什么优缺点呢？</p>
<ul>
<li>big-endian相对来说更符合人类阅读习惯</li>
<li>big-endian在判断数字的正负上比较有优势，只要取第一个字节的一个位的值就可以判断。</li>
<li>little-endian在数据类型转换上比较有优势，因为同一个数字在不同位数的数据类型中排列完全相同。</li>
</ul>
<p>关于类型转换我们试着用一个无符号整型10（二进制为1010）在8位、16位、32位整型中的存储方式说明:</p>
<ul>
<li>big-endian</li>
</ul>
<p>&nbsp;&nbsp;8位 0000 1010<br>16位 0000 0000 0000 1010<br>32位 0000 0000 0000 0000 0000 0000 0000 1010</p>
<ul>
<li>little-endian</li>
</ul>
<p>&nbsp;&nbsp;8位 1010 0000<br>16位 0000 1010 0000 0000<br>32位 0000 1010 0000 0000 0000 0000 0000 0000</p>
<p>从示例中可以看出，如果使用little-endian保存数据，32位的10转成16位的10需要从左到右复制16位，转成8位则是复制8位，后边直接截断不管了，极其方便。而big-endian方式则需要移动位游标再进行复制，性能上是little-endian更高。</p>
<p>需要提一下的是，网络上传输数据时一率采用big-endian进行传输，这是为了防止数据源跟数据接收端使用的存储方式不同而导致发生数据错乱。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现有两大CPU派系PowerPC以及Intel在数据存储上存在着差异，二者分别采用了big-endian以及little-endian方式保存一个多字节的数字。原本我从来没关注过这个问题，现有的工具已经把它们的差异封装得很好了，直到我最近尝试去操作了一些二进制数据才意识到我需要关注一下。&lt;br&gt;
    
    </summary>
    
      <category term="其它技术话题" scheme="https://bennyzheng.github.io/categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF%E8%AF%9D%E9%A2%98/"/>
    
    
      <category term="Binary" scheme="https://bennyzheng.github.io/tags/Binary/"/>
    
      <category term="Endian" scheme="https://bennyzheng.github.io/tags/Endian/"/>
    
  </entry>
  
  <entry>
    <title>缓冲数组以及数据视图</title>
    <link href="https://bennyzheng.github.io/archivers/2016/11/arraybuffer-and-dataview/"/>
    <id>https://bennyzheng.github.io/archivers/2016/11/arraybuffer-and-dataview/</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2016-11-26T03:17:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Javascript在数据的处理上一直不是强项，比如数字不分整型和浮点数统一使用了64位浮点数，如果涉及到二进制运算则显得非常无力，在数据传输上也非常浪费带宽。在ES6针对Javascript二进制数据处理上的无力引入了原始缓冲区ArrayBuffer，并且还提供了多种位数的int类型数组以及数据视图来处理数据。<br><a id="more"></a></p>
<h1 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h1><p>ArrayBuffer是ES6新引入的用于处理二进制数组的缓冲区对象，它不提供对数据的操作能力，提供的是二进制数据的存储。</p>
<p>ArrayBuffer跟Array比较相似，它是一个定长的数组，在初始化后就无法改变长度。每个元素都是一个字节（8bit），相当于C语言中的char，所以如果它的长度是10，就是10字节，绝无例外。</p>
<p>在这里要特别提一下，我们平时编程所需的所有的数据都可以用不同数量的byte表示，比如32位系统中的int类型长度是4，其实它就是拿4个连续的字节拼凑而成的一段空间。</p>
<p>ArrayBuffer就是以字节为单位的缓冲区，再配上对应的API（TypeArray or DataView）来做数据的操作。</p>
<p>ArrayBuffer需要使用new关键词进行实例化，参数为缓冲区的大小：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="built_in">ArrayBuffer</span>(<span class="number">1024</span>); <span class="comment">// 1024个字节，即1kb</span></div></pre></td></tr></table></figure>
<p>它提供了一个属性以及一个方法： </p>
<ul>
<li>byteLength - 只读属性，获取本缓冲数组的长度，由于一个元素就是1字节，其实这里也可以当成该缓冲区申请了多少字节的内存空间。</li>
<li>slice(begin[, end]) - 返回一个新的ArrayBuffer，并使用当前ArrayBuffer从begin到end之间的数据填充，如果end省略则是从begin到缓冲区结束。</li>
</ul>
<p>同时它还提供了一个静态方法：</p>
<ul>
<li>ArrayBuffer.isView(arg) - 如果参数是TypeArray或者DataView，则返回true，否则返回false。</li>
</ul>
<h1 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h1><p>之前提到过ArrayBuffer仅仅是提供了对数据的存储，相当于动态申请了一段内存（当然你不需要像C/C++一般去释放它，或者在不需要的时候也可以将其设置为null由gc自动释放），对于这段缓冲区的操作则是由一组TypeArray以及灵活度更高的DataView对象来提供。</p>
<h2 id="TypeArray"><a href="#TypeArray" class="headerlink" title="TypeArray"></a>TypeArray</h2><p>类型数组提供了几种强类型数组对ArrayBuffer中的数据进行读写，其中包括：</p>
<ul>
<li>Int8Array - 8位的整型数组，由于ArrayBuffer每个元素就是1字节，也就是8位，所以Int8Array的长度就是ArrayBuffer的长度。</li>
<li>Uint8Array - 8位的无符号整型数组，int8使用了7位来保存数据，1位来当符号位以标识数据的正负，而无符号整型则将8位全部用来保存数据，只能保存非负整数，同样它的长度是ArrayBuffer的长度。</li>
<li>Uint8ClampedArray - 8位的无符号整型数组，它与Uint8Array在处理超出范围的数据上的做法略有不同。</li>
<li>Int16Array - 16位的整型数组，使用2个字节凑成一个int16，也就是ArrayBuffer(1024)可以被当成一个长度为512的int16数组使用。</li>
<li>Uint16Array - 16位的无符号整型数组，与Uint8Array类似，仅是每个元素由两个字节组成。</li>
<li>Int32Array - 32位的整型数组，使用4个字节凑成一个int32，也就是ArrayBuffer(1024)可以被当成一个长度为256的int32数组使用。</li>
<li>Uint32Array - 32位的无符号整型数组</li>
<li>Float32Array - 32位的IEEE浮点数数组（单精度float）</li>
<li>Float64Array - 64位的IEEE浮点数数组（双精度float)</li>
</ul>
<p>吐槽一下：这些类型数组以及ES6新引入的类、TypeScript什么的都感觉像是在打以前吹揍着”脚本语言就应该简单，弱类型是多么的方便”的大神们的脸。</p>
<p>曾几何时，我还在流着冷汗看着试卷想着int在32位系统上应该是占了几位，long又是占了几位，没想到当了前端还是要面对它们，感谢ECMA。</p>
<p>类型数组提供的初始化方式、API都是一模一样的，除了元素类型。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化一个TypeArray有多种方法：</p>
<ul>
<li>new TypeArray(length)<br>指明元素个数来创建一个类型数组：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接创建一个1024个元素的</span></div><div class="line"><span class="keyword">var</span> length = <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="comment">// 占了1024 * 1个字节，即1024个字节</span></div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(length);</div><div class="line"><span class="built_in">console</span>.log(int8Array.byteLength); <span class="comment">// 1024</span></div><div class="line"></div><div class="line"><span class="comment">// 占了1024 * 2个字节，即2048个字节</span></div><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(length);</div><div class="line"><span class="built_in">console</span>.log(int16Array.byteLength); <span class="comment">// 2048</span></div></pre></td></tr></table></figure>
<ul>
<li>new TypeArray(typedArray)<br>从一个已经存在的类型数组创建新的类型数组，要特别注意的是它们仅仅是复制关系。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">1024</span>);</div><div class="line"><span class="built_in">console</span>.log(int8Array.byteLength); <span class="comment">// 1024</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(int8Array);</div><div class="line"><span class="built_in">console</span>.log(int16Array.byteLength); <span class="comment">// 2048</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> newInt8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(int16Array);</div><div class="line"><span class="built_in">console</span>.log(newInt8Array.byteLength); <span class="comment">// 1024</span></div></pre></td></tr></table></figure>
<p>这里需要考虑到一个情况，一个范围较大的类型可以安全地存放范围较小的类型值，可是反过来的话就不行了，比如int8的范围是-128到127，int16是-32768到+32767。下边示例则证明了如果发生了数据溢出，则会将数据的一部份截断，比如int16是2个字节，而int8是1个字节，那么将会保留一个字节，然后抛弃另一个字节，导致数据变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 超出int8的数值范围了，int8的数字范围是-128到127</span></div><div class="line">int16Array[<span class="number">0</span>] = <span class="number">1290</span>;</div><div class="line">int16Array[<span class="number">1</span>] = <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(int16Array);</div><div class="line"></div><div class="line"><span class="comment">// 在我的机子的运行结果是 "1290 1024 10 0"</span></div><div class="line"><span class="comment">// 这里为什么会得到10和0，后边会解释</span></div><div class="line"><span class="built_in">console</span>.log(int16Array[<span class="number">0</span>], int16Array[<span class="number">1</span>], int8Array[<span class="number">0</span>], int8Array[<span class="number">1</span>]);</div></pre></td></tr></table></figure>
<ul>
<li>new TypeArray(object)<br>从一个对象中创建类型数组，对象类型我只试出Array可以，应该还有其它的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>, <span class="number">2</span>]);</div><div class="line"><span class="comment">// Int16Array [ 1, 2 ]</span></div><div class="line"><span class="built_in">console</span>.log(int16Array);</div></pre></td></tr></table></figure>
<ul>
<li>new TypeArray(buffer [, byteOffset [, length]])<br>从一个已经存在的ArrayBuffer对象中创建类型数组，同时可以指定开始的位置以及长度来针对ArrayBuffer的某个区域进行操作。</li>
</ul>
<p>要特别注意的是，byteOffset是指从第几个字节算起，而length参数是指TypeArray拥有多少个元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1024</span>);</div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer, <span class="number">2</span>, <span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer, <span class="number">2</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">// 2 2</span></div><div class="line"><span class="built_in">console</span>.log(int8Array.length, int8Array.byteLength);</div><div class="line"><span class="comment">// 2 4 由于是int16，所以2个int16占了4个字节</span></div><div class="line"><span class="built_in">console</span>.log(int16Array.length, int16Array.byteLength);</div></pre></td></tr></table></figure>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ul>
<li>TypeArray.BYTES_PER_ELEMENT - 返回该种TypeArray（注意，不要直接写TypeArray，应该是Int8Array之类的对象）每个元素占的字节数。</li>
<li>TypeArray.from(source[, mapFn[, thisArg]]) - 从一个可遍历的对象(Set、Array、String之类)中创建一个类型数组。<br><em>这里要特别注意当你需要传第三个参数用来给mapFn当this的时候，请不要把mapFn写成箭头函数。</em></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span> : <span class="number">2</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// Int8Array [ 1, 2, 3 ]</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Int8Array</span>.from(array));</div><div class="line"></div><div class="line"><span class="comment">// Int8Array [ 2, 4, 6 ]</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Int8Array</span>.from(array, (x) =&gt; (x + x)));</div><div class="line"></div><div class="line"><span class="comment">// &#123;&#125;</span></div><div class="line"><span class="comment">// &#123;&#125;</span></div><div class="line"><span class="comment">// &#123;&#125;</span></div><div class="line"><span class="comment">// Int8Array [ 2, 4, 6 ]</span></div><div class="line"><span class="comment">// 请不要使用箭头函数！因为箭头函数的this是不可改变的！</span></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    <span class="built_in">Int8Array</span>.from(array, x =&gt; &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> x * <span class="number">2</span>;</div><div class="line">    &#125;, obj)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// &#123; a: 2 &#125;</span></div><div class="line"><span class="comment">// &#123; a: 2 &#125;</span></div><div class="line"><span class="comment">// &#123; a: 2 &#125;</span></div><div class="line"><span class="comment">// Int8Array [ 3, 4, 5 ]</span></div><div class="line"><span class="comment">// 不使用箭头函数后，obj生效了！</span></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    <span class="built_in">Int8Array</span>.from(array, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> x + <span class="keyword">this</span>.a;</div><div class="line">    &#125;, obj)</div><div class="line">);</div></pre></td></tr></table></figure>
<ul>
<li>TypeArray.of(element0[, element1[, …[, elementN]]]) - 将所有参数拼装成一个类型数组。要特别注意的是如果元素不合法，则会得到0.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Int8Array [ 1, 2, 3, 0 ]</span></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    <span class="built_in">Int8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>])</div><div class="line">);</div></pre></td></tr></table></figure>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul>
<li>buffer - TypeArray内部使用的ArrayBuffer对象，如果将一个外部ArrayBuffer当参数构造了一个TypeArray，那么该buffer就是那个外部ArrayBuffer。如果为同一个ArrayBuffer建立两个TypeArray，当使用了其中一个TypeArray的API对数据做修改，另一个也会生效，因为它们使用了同一个数据源。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer);</div><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// Int16Array [ 0 ] Int8Array [ 0, 0 ]</span></div><div class="line"><span class="built_in">console</span>.log(int16Array, int8Array);</div><div class="line">int16Array[<span class="number">0</span>] = <span class="number">123456</span>;</div><div class="line"><span class="comment">// Int16Array [ -7616 ] Int8Array [ 64, -30 ]</span></div><div class="line"><span class="comment">// 二者都变了，因为ArrayBuffer变了</span></div><div class="line"><span class="built_in">console</span>.log(int16Array, int8Array);</div></pre></td></tr></table></figure>
<ul>
<li>byteLength  - 获取TypeArray使用的ArrayBuffer的字节长度，与length不同的是它的值是以字节计算的，所以不会因为TypeArray的类型不同而发生变化。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1024</span>);</div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer);</div><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 1024 1024</span></div><div class="line"><span class="built_in">console</span>.log(int8Array.byteLength, int16Array.byteLength);</div></pre></td></tr></table></figure>
<ul>
<li>byteOffset - 保存了当前TypeArray操作的缓冲区域的起始位置，它是按字节算的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1024</span>);</div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer, <span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 1 0 </span></div><div class="line"><span class="built_in">console</span>.log(int8Array.byteOffset, int16Array.byteOffset);</div></pre></td></tr></table></figure>
<ul>
<li>length - 保存了当前TypeArray的元素个数，该属性跟Array一致，在这里特地列出来是为了跟byteLength做对比。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer);</div><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 10 5</span></div><div class="line"><span class="built_in">console</span>.log(int8Array.length, int16Array.length);</div></pre></td></tr></table></figure>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>TypeArray实现了大部份Array的方法，所以你可以调用类似map、every之类的方法处理数据。这方面的方法与属性就不在这里数说了，仅列出Array没有的。</p>
<ul>
<li>set(array|typeArray [,offset])<br>将一个数组或者类型数组复制到TypeArray指定的位置中，如果不指定位置则是从头覆盖。如果数据超出范围，则会将数据截断。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 注意，它必须是一个Array或者TypeArray！</span></div><div class="line">int8Array.set([<span class="number">5</span>], <span class="number">2</span>);</div><div class="line"><span class="comment">// Int8Array [ 0, 0, 5, 0, 0, 0, 0, 0, 0, 0 ]</span></div><div class="line"><span class="built_in">console</span>.log(int8Array);</div><div class="line"><span class="comment">// Int8Array [ 64, 0, 5, 0, 0, 0, 0, 0, 0, 0 ] 被截断了</span></div><div class="line">int8Array.set([<span class="number">123456</span>]);</div><div class="line"><span class="built_in">console</span>.log(int8Array);</div></pre></td></tr></table></figure>
<ul>
<li>subarray([begin [,end]])<br>返回指定开始以及结束位置之前的元素组成的新同类型TypeArray。<br>这里要注意以下两点：<ul>
<li>返回的新TypeArray与当前TypeArray是共享缓冲区的，也就是修改了其中一个的值，也同样会影响另一个。</li>
<li>返回的新TypeArray不包含end下标元素</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line"><span class="keyword">var</span> subarray = int8Array.subarray(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="comment">// Int8Array [ 2, 3 ]</span></div><div class="line"><span class="comment">// 对应着int8Array[1]以及int8Array[2]，不包含int8Array[3]</span></div><div class="line"><span class="built_in">console</span>.log(subarray);</div><div class="line"></div><div class="line">int8Array[<span class="number">2</span>] = <span class="number">20</span>;</div><div class="line"><span class="comment">// Int8Array [ 2, 20 ] 注意，subarray[1]被更改了</span></div><div class="line"><span class="built_in">console</span>.log(subarray);</div></pre></td></tr></table></figure>
<h2 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h2><p>DataView提供了相对TypeArray更为灵活的方式用于操作数据，从TypeArray的各种示例上看，TypeArray其实就对应着C语言的数组（定长、元素同类型），而DataView则可以操作类似结构体的东西，它允许你随时切换不同的类型读写数据。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>new DataView(buffer [, byteOffset [, byteLength]])</p>
<p>DataView只可以使用ArrayBuffer作为操作对象，同时允许指定操作区域，这个跟TypeArray是一致的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"></div><div class="line"><span class="comment">// DataView &#123;</span></div><div class="line"><span class="comment">//     byteLength: 10,</span></div><div class="line"><span class="comment">//     byteOffset: 0,</span></div><div class="line"><span class="comment">//     buffer: ArrayBuffer &#123; byteLength: 10 &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="built_in">console</span>.log(view);</div></pre></td></tr></table></figure>
<h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><p>与TypeArray一模一样，DataView拥有buffer、byteOffset以及byteLength三个成员变量，它们的作用也是一样的，所以这里不再详说。</p>
<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><p>DataView的成员方法提供了一系列的get、set方法，用法基本上一致： </p>
<ul>
<li>get 在byteOffset指定的位置读取相应类型的值，littleEndian指定数据存储是高位优先还是低位优先<ul>
<li>getInt8(byteOffset)</li>
<li>getUint8(byteOffset)</li>
<li>getInt16(byteOffset [, littleEndian])</li>
<li>getUint16(byteOffset [, littleEndian])</li>
<li>getInt32(byteOffset [, littleEndian])</li>
<li>getUint32(byteOffset [, littleEndian])</li>
<li>getFloat32(byteOffset [, littleEndian])</li>
<li>getFloat64(byteOffset [, littleEndian])</li>
</ul>
</li>
<li>set 在byteOffset指定的位置写入相应类型的值，littleEndian指定数据存储是高位优先还是低位优先<ul>
<li>setInt8(byteOffset, value)</li>
<li>setUint8(byteOffset, value)</li>
<li>setInt16(byteOffset, value [, littleEndian])</li>
<li>setUint16(byteOffset, value [, littleEndian])</li>
<li>setInt32(byteOffset, value [, littleEndian])</li>
<li>setUint32(byteOffset, value [, littleEndian])</li>
<li>setFloat32(byteOffset, value [, littleEndian])</li>
<li>setFloat64(byteOffset, value [, littleEndian])</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line">view.setInt8(<span class="number">0</span>, <span class="number">10</span>);</div><div class="line"><span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>));</div></pre></td></tr></table></figure>
<p>关于Endian方面请看后边章节。</p>
<h1 id="数据的存储方式"><a href="#数据的存储方式" class="headerlink" title="数据的存储方式"></a>数据的存储方式</h1><p>说说这些类型数组元素的数据表示方式吧！当然，我不打算在这里全部讲完，特别是IEEE规定的单精度浮点数和双精度浮点数是怎么用二进制表示的估计能另起一篇文章。</p>
<p>一个整型数字写成2进制之后以书写习惯来说左边是高位，右边是低位。举个例子，int8的5使用二进制是这么表示的：</p>
<p>0000 0101</p>
<p>最左边的0是符号位，表示非负数，101则是5的二进制写法。</p>
<p>负数无法使用非负数的规则来表示，比如-1用非负数的规则表示是：</p>
<p>1000 0001</p>
<p>考虑到-1如果加上1值应该为0，那么该值加上1却会变成-2：</p>
<p>1000 0010</p>
<p>也就是在计算方式上出现问题了，所以二进制是采用了补码的方式来表示，补码可以完全不考虑符号位，它的规则如下：</p>
<ul>
<li>非负数直接用正常的二进制数表示</li>
<li>负数是绝对值二进制取反加1</li>
</ul>
<p>按这种规则，-1的绝对值二进制是：</p>
<p>0000 0001</p>
<p>取反后是：</p>
<p>1111 1110</p>
<p>再加1则是：</p>
<p>1111 1111</p>
<p>我们再尝试给它加上1，看看值是多少：</p>
<p>1 0000 0000</p>
<p>明显高位溢出了，于是将高位多余的1截掉变成：</p>
<p>0000 0000</p>
<p>它的值如我们所料是0，这就是补码。uint8由于没有正负之分，它的所有值都是非负数，所以就不需要考虑补码。</p>
<h1 id="数据溢出截断"><a href="#数据溢出截断" class="headerlink" title="数据溢出截断"></a>数据溢出截断</h1><p>首先需要了解一下int16用二进制是如何表示的，以3850为例子，它的二进制表示方式是这样子的：</p>
<p>00001111 00001010</p>
<p>int16占了两个字节，因此它被截成两断，我们把左边的字节称为高位字节，右边的字节称为低位字节。在内存中它是如何存放的呢？建立一个Int8Array来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer);</div><div class="line"></div><div class="line">int16Array[<span class="number">0</span>] = <span class="number">3850</span>;</div><div class="line"></div><div class="line"><span class="comment">// Int16Array [ 3850 ]</span></div><div class="line"><span class="built_in">console</span>.log(int16Array);</div><div class="line"></div><div class="line"><span class="comment">// Int8Array [ 10, 15 ]</span></div><div class="line"><span class="built_in">console</span>.log(int8Array);</div></pre></td></tr></table></figure>
<p>从运行结果看，3850被截断成两个int8值：</p>
<p>int8Array[0] = 10 = 00001010<br>int8Array[1] = 15 = 00001111</p>
<p>看起来很反人类是吧？高位字节不是放在左边下标为0的字节上，却放在右边下标为1的字节上，跟我们的书写习惯反过来了！</p>
<p>事实上，数据在内存中存储并没有硬性规则高位字节必须放在左边（虽然它更符合人类阅读习惯），具体实现也是根据当前CPU的实现。大多数计算机是以高位优先的顺序存放数据（即高位在左，低位在右），但基于Intel CPU的计算机则是反过来以低位优先存放数据，我的本子就是Intel CPU的，因此我的运行结果就是Int8Array [ 10, 15 ]，或许换个电脑就会变成Int8Array [ 15, 10 ]。</p>
<p>那么当数据溢出截断又是怎么处理的？尝试着给一个int8字节赋值3850，看看最终得到的值是什么:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>([<span class="number">3850</span>]);</div><div class="line"><span class="comment">//Int8Array [ 10 ]</span></div><div class="line"><span class="built_in">console</span>.log(int8Array);</div></pre></td></tr></table></figure>
<p>很明显，它把15抛弃了，也就是保存了低位字节，抛弃高位。事实上，溢出处理在各种CPU上都是保留低位能保留的字节，把高位的截断，这个与数据存储是按高位优先还是低位优先没什么关系。</p>
<h1 id="字节序处理"><a href="#字节序处理" class="headerlink" title="字节序处理"></a>字节序处理</h1><p>请先看以下示例代码在我机子上跑的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</div><div class="line"><span class="keyword">var</span> int16Array = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer);</div><div class="line">view.setInt8(<span class="number">0</span>, <span class="number">10</span>);</div><div class="line"><span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt8(<span class="number">0</span>))</div><div class="line"><span class="comment">// 2560 用二进制表示是：00001010 00000000，</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>));</div><div class="line"></div><div class="line">int16Array[<span class="number">0</span>] = <span class="number">10</span>;</div><div class="line"><span class="comment">// 2560!</span></div><div class="line"><span class="built_in">console</span>.log(view.getInt16(<span class="number">0</span>));</div></pre></td></tr></table></figure>
<p>仔细看结果，很明显，view使用的是高位优先的读写方式，而TypeArray使用的是低位优先的读写方式。在内存中两个字节的数据在setInt8(0, 10)的时候会变成</p>
<p>00001010 00000000</p>
<p>按照我计算机的读写规则应该是低位优先，也就是实际上这里应该被解读成</p>
<p>00000000 00001010</p>
<p>也就是得到10，但实际上使用view却得到了2560，也就是高位优先。</p>
<p>DataView默认是使用big-endian方式，也就是高位优先进行读写。但在读写多字节数据的时候，可以通过传入值为true的little-endian参数来要求使用低位优先规则读写数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript在数据的处理上一直不是强项，比如数字不分整型和浮点数统一使用了64位浮点数，如果涉及到二进制运算则显得非常无力，在数据传输上也非常浪费带宽。在ES6针对Javascript二进制数据处理上的无力引入了原始缓冲区ArrayBuffer，并且还提供了多种位数的int类型数组以及数据视图来处理数据。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://bennyzheng.github.io/categories/javascript/"/>
    
    
      <category term="Node.js" scheme="https://bennyzheng.github.io/tags/Node-js/"/>
    
      <category term="Binary" scheme="https://bennyzheng.github.io/tags/Binary/"/>
    
      <category term="TypeArray" scheme="https://bennyzheng.github.io/tags/TypeArray/"/>
    
      <category term="ArrayBuffer" scheme="https://bennyzheng.github.io/tags/ArrayBuffer/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - buffer模块</title>
    <link href="https://bennyzheng.github.io/archivers/2016/11/node-buffer/"/>
    <id>https://bennyzheng.github.io/archivers/2016/11/node-buffer/</id>
    <published>2016-11-19T16:00:00.000Z</published>
    <updated>2016-11-26T03:17:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚把Javascript本身新引入的TypeArray以及ArrayBuffer好了解了一下，Node.js针对二进制数据提供了buffer模块，手册中提到Buffer是Int8Array的另一种更适合Node.js使用的实现方式（我看是因为之前TypeArray还没实现结果先出了Buffer，现在准备一条道走到黑吧……不过确实用起来挺好用）。在Node.js的数据交换过程中，buffer模块经常会被使用到，比如数据流。<br><a id="more"></a></p>
<h1 id="Buffer的初始化"><a href="#Buffer的初始化" class="headerlink" title="Buffer的初始化"></a>Buffer的初始化</h1><p>使用buffer模块不需要使用require引入模块，全局提供了一个Buffer对象（可见它使用频率有多频繁）。虽然Buffer可以使用new关键词创建一个实例，但手册上明确表示它已经被弃用，我们应该使用alloc之类的API创建。</p>
<p>需要特别注意的是：</p>
<ul>
<li>Buffer是固定大小的（fixed-size），从实例化后就无法再改变它的内存大小。</li>
<li>Buffer是动态申请的内存，它并不在V8引擎的堆里。</li>
</ul>
<h2 id="Buffer-form-array"><a href="#Buffer-form-array" class="headerlink" title="Buffer.form(array)"></a>Buffer.form(array)</h2><p>从数组中创建Buffer，需要注意的是这里的数组是指普通的Array、TypeArray以及类数组的的对象。需要注意的是从数组或类数组对象创建的Buffer是新申请内存并且把数组内容复制到Buffer中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通数组</span></div><div class="line"><span class="keyword">var</span> buffer = Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"><span class="comment">// &lt;Buffer 01 02 03&gt;</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div><div class="line"></div><div class="line"><span class="comment">// TypeArray</span></div><div class="line">buffer = Buffer.from(<span class="keyword">new</span> <span class="built_in">Int8Array</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</div><div class="line"><span class="comment">// &lt;Buffer 02 03 04&gt;</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 试一下TypeArray</span></div><div class="line"><span class="keyword">var</span> arrayBuffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(arrayBuffer);</div><div class="line"><span class="comment">// 从TypeArray创建</span></div><div class="line">buffer = Buffer.from(int8Array);</div><div class="line">int8Array[<span class="number">0</span>] = <span class="number">12</span>;</div><div class="line"></div><div class="line"><span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></div><div class="line"><span class="comment">// 第一个字节没有变，证明这里是复制了一个副本</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 如果想让它们共享内存，可以从TypeArray的缓冲区创建：</span></div><div class="line">buffer = Buffer.from(int8Array.buffer);</div><div class="line"><span class="comment">// &lt;Buffer 0c 00 00 00 00 00 00 00 00 00&gt;</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div></pre></td></tr></table></figure>
<h2 id="Buffer-from-arrayBuffer-byteOffset-length"><a href="#Buffer-from-arrayBuffer-byteOffset-length" class="headerlink" title="Buffer.from(arrayBuffer[, byteOffset [, length]])"></a>Buffer.from(arrayBuffer[, byteOffset [, length]])</h2><p>从ArrayBuffer中创建Buffer，同时可以指定开始的位置byteOffset以及字节数length。需要注意的是从ArrayBuffer创建的Buffer是与ArrayBuffer共享内存的，随便改哪个都会导致另一个更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrayBuffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> int8Array = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(arrayBuffer);</div><div class="line"><span class="keyword">var</span> buffer = Buffer.from(arrayBuffer);</div><div class="line"></div><div class="line"><span class="comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt; 初始值</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div><div class="line">int8Array[<span class="number">0</span>] = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// &lt;Buffer 0a 00 00 00 00 00 00 00 00 00&gt;</span></div><div class="line"><span class="comment">// 第一个字节变成了10，证明从arrayBuffer创建的是共享内存的</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div></pre></td></tr></table></figure>
<h2 id="Buffer-alloc-size-fill-encoding"><a href="#Buffer-alloc-size-fill-encoding" class="headerlink" title="Buffer.alloc(size[, fill[, encoding]])"></a>Buffer.alloc(size[, fill[, encoding]])</h2><p>直接申请一段内存，内存大小为size个字节。新申请的内存每个字节默认将值填为0，也可以通过fill设置填充选项。注意这里相当于调用了buffer的fill方法，填充编码默认为utf-8。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &lt;Buffer 61 61 61 61 61 61 61 61 61 61&gt;</span></div><div class="line"><span class="comment">// 使用'a'填充每个字节</span></div><div class="line"><span class="keyword">var</span> buffer = Buffer.alloc(<span class="number">10</span>, <span class="string">'a'</span>);</div><div class="line"><span class="built_in">console</span>.log(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 使用'ab'填充整个buffer，由于buffer长度为10，ab会被不断循环填充。</span></div><div class="line"><span class="comment">// 同时指明编码格式为utf-8</span></div><div class="line">buffer = Buffer.alloc(<span class="number">10</span>, <span class="string">'ab'</span>, <span class="string">"utf-8"</span>);</div><div class="line"><span class="built_in">console</span>.log(buffer);</div></pre></td></tr></table></figure>
<h2 id="Buffer-allocUnsafe-size"><a href="#Buffer-allocUnsafe-size" class="headerlink" title="Buffer.allocUnsafe(size)"></a>Buffer.allocUnsafe(size)</h2><p>直接申请一段内存，内存大小为size个字节。与alloc不同的是，它标明了是”unsafe”，其实就是申请内存时不使用0将原有内存内容擦除因此不安全，但也因此它相对于alloc来说更快。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = Buffer.allocUnsafe(<span class="number">10</span>);</div><div class="line"><span class="comment">// 每次buffer的内容都是不可预知的</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div></pre></td></tr></table></figure>
<h2 id="Buffer-allocUnsafeSlow-size"><a href="#Buffer-allocUnsafeSlow-size" class="headerlink" title="Buffer.allocUnsafeSlow(size)"></a>Buffer.allocUnsafeSlow(size)</h2><p>申请一段内存，内存大小为size个字节。这个函数使用了Slow这个词，它的意思是说这块内存将是独享的，不允许Buffer按照规则决定是否从预申请的内存池中分配内存（因此它是缓慢的，大概就是这个意思）。事实上，所有不符合内存池分配规则的Buffer都是独享的，只不过这里特地要求不考虑与其它Buffer共享一块内存池罢了，没有什么大的区别。<strong>注意，这个方法平时不需要考虑使用，它更多的是提供给Node.js源码开发者使用的，普通开发者应该使用Buffer</strong>。</p>
<h1 id="数据的读写"><a href="#数据的读写" class="headerlink" title="数据的读写"></a>数据的读写</h1><p>Buffer针对各种数据类型提供了多种API用于读写操作，如果数据类型不是int8还需要区分字节序是高位优先还是低位优先，以BE(BIG_ENDIAN)和LE(LITTLE_ENDIAN)结尾区分。</p>
<p>Buffer的读写操作跟Javascript的TypeArray提供的读写操作非常类似，唯一需要注意的是noAssert参数，请谨慎使用该参数。noAssert如果被设置为true，意味着在写数据的时候不会检测写入的数据是否会超出当前Buffer分配给数据存储的内存区域！这可能会导致灾难性地问题。</p>
<p>Buffer允许把它当数组一般使用下标读写某个字节，但同时也提供了大量的方法方便读写：</p>
<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><ul>
<li>readInt8(offset[, noAssert]) - 读取一个8位的整型</li>
<li>readUInt8(offset[, noAssert]) - 读取一个8位的无符号整型</li>
<li>readInt16BE(offset[, noAssert]) - 高位优先读取16位整型</li>
<li>readInt16LE(offset[, noAssert]) - 低位优先读取16位整型</li>
<li>readUInt16BE(offset[, noAssert]) - 高位优先读取16位无符号整型</li>
<li>readUInt16LE(offset[, noAssert]) - 低位优先读取16位无符号整型</li>
<li>readInt32BE(offset[, noAssert]) - 高位优先读取32位整型</li>
<li>readInt32LE(offset[, noAssert]) - 低位优先读取32位整型</li>
<li>readUInt32BE(offset[, noAssert]) - 高位优先读取32位无符号整型</li>
<li>readUInt32LE(offset[, noAssert]) - 低位优先读取32位无符号整型</li>
<li>readFloatBE(offset[, noAssert]) - 高位优先读取32位浮点数</li>
<li>readFloatLE(offset[, noAssert]) - 低位优先读取32位浮点数</li>
<li>readDoubleBE(offset[, noAssert]) - 高位优先读取64位浮点数</li>
<li>readDoubleLE(offset[, noAssert]) - 低位优先读取64位浮点数</li>
<li>readIntBE(offset, byteLength[, noAssert]) - 高位优先读取一个指定字节数的整型，最大48位</li>
<li>readIntLE(offset, byteLength[, noAssert]) - 低位优先读取一个指定字节数的整型，最大48位</li>
<li>readUIntBE(offset, byteLength[, noAssert]) - 高位优先读取一个指定字节数的无符号整型，最大48位</li>
<li>readUIntLE(offset, byteLength[, noAssert]) - 低位优先读取一个指定字节数的无符号 整型，最大48位</li>
</ul>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><ul>
<li>writeInt8(value, offset[, noAssert]) - 写入一个8位整型</li>
<li>writeUInt8(value, offset[, noAssert]) - 写入一个8位无符号整型</li>
<li>writeInt16BE(value, offset[, noAssert]) - 高位优先写入一个16位整型</li>
<li>writeInt16LE(value, offset[, noAssert]) - 低位优先写入一个16位整型</li>
<li>writeUInt16BE(value, offset[, noAssert]) - 高位优先写入一个16位无符号整型</li>
<li>writeUInt16LE(value, offset[, noAssert]) - 低位优先写入一个16位无符号整型</li>
<li>writeInt32BE(value, offset[, noAssert]) - 高位优先写入一个32位整型</li>
<li>writeInt32LE(value, offset[, noAssert]) - 低位优先写入一个32位整型</li>
<li>writeUInt32BE(value, offset[, noAssert]) - 高位优先写入一个32位无符号整型</li>
<li>writeUInt32LE(value, offset[, noAssert]) - 低位优先写入一个32位无符号整型</li>
<li>writeFloatBE(value, offset[, noAssert]) - 高位优先写入一个32位浮点数</li>
<li>writeFloatLE(value, offset[, noAssert]) - 低位优先写入一个32位浮点数</li>
<li>writeDoubleBE(value, offset[, noAssert]) - 高位优先写入一个64位浮点数</li>
<li>writeDoubleLE(value, offset[, noAssert]) - 低位优先写入一个64位浮点数</li>
<li>write(string[, offset[, length]][, encoding]) - 将一个字符串写入指定的位置，可以通过length限制长度以及通过encoding设置编码，编码默认是UTF-8。</li>
<li>writeIntBE(value, offset, byteLength[, noAssert]) - 高位优先将value值写入指定的位置，需要明确指定value值占的位数</li>
<li>writeIntLE(value, offset, byteLength[, noAssert]) - 低位优先将value值写入指定的位置，需要明确指定value值占的位数</li>
</ul>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>Buffer提供了几种方法可以将内容序列化：</p>
<ul>
<li>toString([encoding[, start[, end]]])<br>以指定的编码返回指定范围的字符串，默认是使用UTF-8，返回全部内容。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = Buffer.from(<span class="string">"hello world"</span>);</div><div class="line"><span class="comment">// world 注意，d的下标是10，这里如果设置end，返回的字符串是不包含end下标的字符的。</span></div><div class="line"><span class="built_in">console</span>.log(buffer.toString(<span class="string">"utf-8"</span>, <span class="number">6</span>, <span class="number">11</span>));</div></pre></td></tr></table></figure>
<ul>
<li>toJSON()<br>将Buffer以{“type”:”Buffer”,”data”:[1,2,3,4,5]}的方式返回一个JSON对象，个人感觉它的格式很死板。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = Buffer.from(<span class="string">"hello world"</span>);</div><div class="line"><span class="comment">// &#123; type: 'Buffer',</span></div><div class="line"><span class="comment">//     data: [ 104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100 ] &#125;</span></div><div class="line"><span class="built_in">console</span>.log(buffer.toJSON());</div></pre></td></tr></table></figure>
<h1 id="字节序处理"><a href="#字节序处理" class="headerlink" title="字节序处理"></a>字节序处理</h1><p>涉及到多字节数据的读写的API都得考虑字节序的问题，在Buffer提供的API中，读写操作基本上都以BE以及LE后缀结尾。当你明确知道当前数据是以高位优先或者低位优先存储，却希望将其做转换的话可以使用以下三个API进行数据处理：</p>
<ul>
<li>swap16() - 将当前Buffer的数据每两个字节视为一个16数字，并反向重排字节。</li>
<li>swap32() - 将当前Buffer的数据每两个字节视为一个32数字，并反向重排字节。</li>
<li>swap64() - 将当前Buffer的数据每两个字节视为一个64数字，并反向重排字节。</li>
</ul>
<p>以16位数字（int16/uint16)为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 8个字节，可以存放4个int16</span></div><div class="line"><span class="keyword">var</span> buffer = Buffer.allocUnsafe(<span class="number">8</span>);</div><div class="line"></div><div class="line">buffer.writeInt16BE(<span class="number">0x0102</span>, <span class="number">0</span>);</div><div class="line">buffer.writeInt16BE(<span class="number">0x0304</span>, <span class="number">2</span>);</div><div class="line">buffer.writeInt16BE(<span class="number">0x0506</span>, <span class="number">4</span>);</div><div class="line">buffer.writeInt16BE(<span class="number">0x0708</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="comment">// &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span></div><div class="line"><span class="comment">// 高位优先，符合人类阅读习惯</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 我认为我现在需要低位优先方式存储，调用swap16进行整理</span></div><div class="line">buffer.swap16();</div><div class="line"></div><div class="line"><span class="comment">// &lt;Buffer 02 01 04 03 06 05 08 07&gt;</span></div><div class="line"><span class="comment">// 它以2个字节为单位将字节顺序调换</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div><div class="line"></div><div class="line"><span class="comment">// 重置一下</span></div><div class="line">buffer.writeInt16BE(<span class="number">0x0102</span>, <span class="number">0</span>);</div><div class="line">buffer.writeInt16BE(<span class="number">0x0304</span>, <span class="number">2</span>);</div><div class="line">buffer.writeInt16BE(<span class="number">0x0506</span>, <span class="number">4</span>);</div><div class="line">buffer.writeInt16BE(<span class="number">0x0708</span>, <span class="number">6</span>);</div><div class="line"></div><div class="line"><span class="comment">// 看看swap32会有啥结果</span></div><div class="line">buffer.swap32();</div><div class="line"></div><div class="line"><span class="comment">// &lt;Buffer 04 03 02 01 08 07 06 05&gt;</span></div><div class="line"><span class="comment">// 它认为4个字节是一个整体，以4个字节为单位将字节顺序调换</span></div><div class="line"><span class="built_in">console</span>.log(buffer);</div></pre></td></tr></table></figure>
<h1 id="缓冲池与性能"><a href="#缓冲池与性能" class="headerlink" title="缓冲池与性能"></a>缓冲池与性能</h1><p>Buffer对象有一个属性叫poolSize，用于设置缓冲池的大小。以下是这个缓冲池的关键性代码，来自Node.js(v6.9.1/lib/buffer.js)源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Buffer.poolSize = <span class="number">8</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="comment">// ....</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPool</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  poolSize = Buffer.poolSize;</div><div class="line">  allocPool = createUnsafeBuffer(poolSize);</div><div class="line">  poolOffset = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">createPool();</div><div class="line"></div><div class="line"><span class="comment">// ....</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocate</span>(<span class="params">size</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FastBuffer();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (size &lt; (Buffer.poolSize &gt;&gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">    <span class="keyword">if</span> (size &gt; (poolSize - poolOffset))</div><div class="line">      createPool();</div><div class="line">    <span class="keyword">var</span> b = allocPool.slice(poolOffset, poolOffset + size);</div><div class="line">    poolOffset += size;</div><div class="line">    alignPool();</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Even though this is checked above, the conditional is a safety net and</span></div><div class="line">    <span class="comment">// sanity check to prevent any subsequent typed array allocation from not</span></div><div class="line">    <span class="comment">// being zero filled.</span></div><div class="line">    <span class="keyword">return</span> createUnsafeBuffer(size);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>createPool函数从内存中申请了8kb的内存，并将其作为当前Buffer的缓冲池。</p>
<p>allocate函数用于分配内存，以下是我对它的注解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocate</span>(<span class="params">size</span>) </span>&#123;</div><div class="line">  <span class="comment">// 当外部申请的内存小于等于0，则直接返回一个FastBuffer</span></div><div class="line">  <span class="comment">// FastBuffer是使用Uint8Array实现的Buffer，这个不在我们关注的话题内</span></div><div class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FastBuffer();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 当申请的内存大小小于缓冲池大小的一半时就开始尝试从已经存在的缓冲区中分配内存</span></div><div class="line">  <span class="keyword">if</span> (size &lt; (Buffer.poolSize &gt;&gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">    <span class="comment">// 如果申请的内存比当前空闲的缓冲池内存（有一部份被用掉给别的Buffer了）还大时</span></div><div class="line">    <span class="comment">// 直接放弃当前缓冲池重建一个新的！</span></div><div class="line">    <span class="keyword">if</span> (size &gt; (poolSize - poolOffset))</div><div class="line">      createPool();</div><div class="line">    <span class="keyword">var</span> b = allocPool.slice(poolOffset, poolOffset + size);</div><div class="line">    poolOffset += size;</div><div class="line">    alignPool();</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Even though this is checked above, the conditional is a safety net and</span></div><div class="line">    <span class="comment">// sanity check to prevent any subsequent typed array allocation from not</span></div><div class="line">    <span class="comment">// being zero filled.</span></div><div class="line">    <span class="comment">// 直接申请新的内存返回</span></div><div class="line">    <span class="keyword">return</span> createUnsafeBuffer(size);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上边的源码解析中可以看到几个点：</p>
<ul>
<li>为了节省申请内存消耗，Buffer直接申请了一块8kb的内存空间当成缓冲池随时用于存放小量数据</li>
<li>如果新建Buffer缓冲区大小小于当前设置的poolSize的一半时（4kb），则会使用缓冲池里的空闲内存分配，省掉申请内存消耗</li>
<li>如果新建Buffer需要的缓冲区大小满足缓冲池分配内存的原则，但当前缓冲池的空余内存又不够用，当前缓冲池会被直接浪费掉，直接申请新的8kb缓冲池。</li>
</ul>
<p>这其实就是用空间换时间的做法，Node.js没有在缓冲池的内存管理上花什么心思，就是不够了就浪费掉申请新的，但很多时候数据量都不会超过4kb，也就是我们大部份操作都不会导致Buffer动态申请内存，提高了性能。</p>
<p>这里特别要注意的是，由于8kb的缓冲池是一次性申请的，只有缓冲池上所有Buffer都设置为null，否则整块缓冲池都不会被释放，也就是内存泄露。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚把Javascript本身新引入的TypeArray以及ArrayBuffer好了解了一下，Node.js针对二进制数据提供了buffer模块，手册中提到Buffer是Int8Array的另一种更适合Node.js使用的实现方式（我看是因为之前TypeArray还没实现结果先出了Buffer，现在准备一条道走到黑吧……不过确实用起来挺好用）。在Node.js的数据交换过程中，buffer模块经常会被使用到，比如数据流。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://bennyzheng.github.io/categories/javascript/"/>
    
    
      <category term="Node.js" scheme="https://bennyzheng.github.io/tags/Node-js/"/>
    
      <category term="Binary" scheme="https://bennyzheng.github.io/tags/Binary/"/>
    
      <category term="Buffer" scheme="https://bennyzheng.github.io/tags/Buffer/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - url模块</title>
    <link href="https://bennyzheng.github.io/archivers/2016/11/node-url/"/>
    <id>https://bennyzheng.github.io/archivers/2016/11/node-url/</id>
    <published>2016-11-19T16:00:00.000Z</published>
    <updated>2016-11-24T14:18:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>URL是每一位网虫都使用过的东西，我记得第一次上网吧玩的时候，网吧老板帮我输了一个地址，在那时候很出名的聊天室网站”碧海银沙”，那时候我觉得上网就是上这个网站聊天，这是我第一次接触到URL。<br><a id="more"></a></p>
<h1 id="URL的结构"><a href="#URL的结构" class="headerlink" title="URL的结构"></a>URL的结构</h1><p>Node.js手册非常形象的使用了下方这张图片作为解读URL结构的示例，图中很清楚地为我们构造出一个完整的URL应该是长什么样的。</p>
<p><img src="/images/2016/11/url.png" alt="Node.js的URL结构图"></p>
<p>Node.js的url模块能够让工程师将一个URL字符串解析成一个对象，它拥有以下属性：</p>
<ul>
<li>href - 保存了完整的url地址。要特别注意的是它会将协议以及域名中的大写字母转成小写字母，至于其它位置的字符则会保持原样。这是因为协议以及域名是大小写不分的，为了方便直接全部都转成小写。</li>
<li>protocol - 小写字母组成的协议类型，比如http:。要特别注意:也是协议的一部份（一直觉得很囧）。</li>
<li>slashes - 一个布尔值，一般是true，它注明url的协议后边是否拥有两个/字符，有些奇葩URL是不带//的。</li>
<li>host - 小写字母组成的域名+端口，二者之间有个冒号隔开。如果直接使用IP访问，那么host值就是IP地址，否则就是域名。另外，如果URL上没有写端口那么这里的值跟hostname一致。举个例子：www.host.com:8080。</li>
<li>auth - URL中附带的认证信息，这个很少使用，毕竟不是很安全。当我们访问一个要求认证的网页时，服务器将会返回http状态码401要求浏览器提供用户认证信息，输入用户名和密码之后它将会在Http请求报文头中以Base64的方式写在Authorization字段中。你也可以使用类似”<a href="http://user:pass/host.com/a.php&quot;的方式直接将用户名和密码（密码可省略，照样弹出窗口让你输入）写在URL中。" target="_blank" rel="external">http://user:pass/host.com/a.php&quot;的方式直接将用户名和密码（密码可省略，照样弹出窗口让你输入）写在URL中。</a></li>
<li>hostname - 域名，跟host不同的是它不带端口。</li>
<li>port - 端口，如果没有该值会使用该协议默认端口，比如http(80)、https(443)、ftp(21)、sftp(22)。</li>
<li>pathname - 请求路径名，它不包含search以及hash。</li>
<li>search - 查询字符串，在URL表现为类似”?id=1”这种形式，要特别注意的是它包含问号(?)。</li>
<li>path - 请求路径，它包含pathname以及search部份，比如”/a/b/c.php?id=1”。许多浏览器并不把URL上的hash部份带到服务器，hash部份一般用于标识本页的某个锚点，因此path这一块是会被附在请求头上送到服务器端。</li>
<li>query - 查询参数，它与search不同之处在于它不带问号，比如”id=1&amp;name=2”。要特别注意的是，使用url.parse解析一个url的时候可以通过设置参数来决定是否对search做解析，如果将parseQueryString参数设置为true，query将会是一个对象，它用键值对的方式保存了search里包含的数据，比如{ id: 1, name: 2 }</li>
<li>hash - 锚点，在URL处于末尾，由#号开始。在平时的网页URL中，浏览器一般不会将其发送到服务器端，它更多的是用在客户端。本意是用于做锚点，可以跳到页面某个特定位置，实际上现在更多的是用来做单页面的路由功能。举例：”#hash”。</li>
</ul>
<p>以下是一个完整的URL对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> urlObject = &#123;</div><div class="line">    <span class="attr">href</span>: <span class="string">"http://user:pass@host.com:8080/p/a/t/h?query=string#hash"</span>,</div><div class="line">    <span class="attr">protocol</span>: <span class="string">"http:"</span>,</div><div class="line">    <span class="attr">slashes</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">auth</span>: <span class="string">'user:pass'</span>,</div><div class="line">    <span class="attr">host</span>: <span class="string">'host.com:8080'</span>,</div><div class="line">    <span class="attr">port</span>: <span class="string">'8080'</span>,</div><div class="line">    <span class="attr">hostname</span>: <span class="string">'host.com'</span>,</div><div class="line">    <span class="attr">hash</span>: <span class="string">'#hash'</span>,</div><div class="line">    <span class="attr">search</span>: <span class="string">'?query=string'</span>,</div><div class="line">    <span class="attr">query</span>: &#123; <span class="attr">query</span>: <span class="string">'string'</span> &#125;, <span class="comment">// 或者 "query=string"</span></div><div class="line">    pathname: <span class="string">'/p/a/t/h'</span>,</div><div class="line">    <span class="attr">path</span>: <span class="string">'/p/a/t/h?query=string'</span>,</div><div class="line">    <span class="attr">href</span>: <span class="string">'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="URL模块API"><a href="#URL模块API" class="headerlink" title="URL模块API"></a>URL模块API</h1><p>URL模块仅提供了3个函数，没有提供类或者其它东西：</p>
<ul>
<li>url.format - 将一个包含必要字段的urlObject格式化成一个合法的URL字符串。</li>
<li>url.parse - 将一个合法的URL字符串转成urlObject，注意URL并不需要包含所有的字段，比如”./“也算是一个URL字符串。</li>
<li>url.resolve - 拥有from以及to两个参数，自动计算出to相对于from的绝对地址。如果from参数省略，则是将to转换为绝对路径。</li>
</ul>
<p>这三个函数除了url.resolve都比较容易理解，至于resolve，手册给出了相应的例子，也比较形象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">url.resolve(<span class="string">'/one/two/three'</span>, <span class="string">'four'</span>)         <span class="comment">// '/one/two/four'</span></div><div class="line">url.resolve(<span class="string">'http://example.com/'</span>, <span class="string">'/one'</span>)    <span class="comment">// 'http://example.com/one'</span></div><div class="line">url.resolve(<span class="string">'http://example.com/one'</span>, <span class="string">'/two'</span>) <span class="comment">// 'http://example.com/two'</span></div></pre></td></tr></table></figure>
<h1 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h1><ul>
<li><p>弄清绝对路径的根目录在哪  </p>
<p>在构建一个页面时为了方便可能会使用绝对路径，绝对路径是以/开头的路径，对绝对路径不大了解的前端可能会就发现直接在服务器上查看HTML文件时正常，但直接双击打开html文件则发生路径错误。这时需要认清这绝对路径的根目录到底是哪里。  </p>
<p>假设我们的站点放在/wwwroot/mysite，访问地址是<a href="http://mysite.com，现在我们需要访问/index.html，它引用了一个路径为/css/site.css的样式文件，它被存放在/wwwroot/mysite/css/site.css。" target="_blank" rel="external">http://mysite.com，现在我们需要访问/index.html，它引用了一个路径为/css/site.css的样式文件，它被存放在/wwwroot/mysite/css/site.css。</a>  </p>
<p>这时候访问<a href="http://mysite.com/index.html，样式能够正常显示，而直接打开/wwwroot/mysite/index.html，则会说找不到/css/site.css。" target="_blank" rel="external">http://mysite.com/index.html，样式能够正常显示，而直接打开/wwwroot/mysite/index.html，则会说找不到/css/site.css。</a>    </p>
<p>这是因为在使用域名访问index.html时，绝对路径是指<a href="http://mysite.com/，映射到磁盘上的地址是/wwwroot/mysite/，而直接打开index.html时，index.html的地址是/wwwroot/mysite/index.html，这时候的绝对路径根目录是/，这时候磁盘上的/css/site.css是不存在的，真正的地址应该是/wwwroot/mysite/css/mysite.css。" target="_blank" rel="external">http://mysite.com/，映射到磁盘上的地址是/wwwroot/mysite/，而直接打开index.html时，index.html的地址是/wwwroot/mysite/index.html，这时候的绝对路径根目录是/，这时候磁盘上的/css/site.css是不存在的，真正的地址应该是/wwwroot/mysite/css/mysite.css。</a></p>
</li>
<li><p>查询字符串的编码  </p>
<p>请求一个URL时许多人弄不清哪里需要编码哪里不需要编码，甚至还重复编码，这里特地做一下说明。另外，服务器端接收到你的值是不需要解码的，因为服务器本身就会帮你解码了。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在发起请求的时候，queryString每个字段以及它的值都应该被编码，比如"/file?键1=值1&amp;键2=值2"应该这么写（也可以使用encodeURI，但url不能带search和hash部份）：  </span></div><div class="line"><span class="keyword">var</span> url = <span class="string">"/file?"</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">"键1"</span>) + <span class="string">"="</span></div><div class="line">    + <span class="built_in">encodeURIComponent</span>(<span class="string">"值1"</span>) + <span class="string">"&amp;"</span></div><div class="line">    + <span class="built_in">encodeURIComponent</span>(<span class="string">"键2"</span>) + <span class="string">"="</span></div><div class="line">    + <span class="built_in">encodeURIComponent</span>(<span class="string">"值2"</span>);</div><div class="line"><span class="comment">// 当然，如果你确认你的key和value都不会有非ASCII字符以及需要转义的字符，你也可以不编码（如果不知道是否需要编码，一定要编码，有利无害）。另外，如果值是一个url,该url也需要做编码：  </span></div><div class="line"><span class="comment">// value本身是一个url，请对它的key和value编码。由于key的值是"key"，我确认它绝对不需要编码（因为encodeURIComponent("key")值同样是key），所以我就省掉了。</span></div><div class="line"><span class="keyword">var</span> value = <span class="string">"http://www.site.com/?key="</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">"这是中文值"</span>);</div><div class="line"><span class="comment">// url的值为value的值，value的值也需要编码。</span></div><div class="line"><span class="keyword">var</span> url = <span class="string">"http://mysite.com/?url="</span> + <span class="built_in">encodeURIComponent</span>(value);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;URL是每一位网虫都使用过的东西，我记得第一次上网吧玩的时候，网吧老板帮我输了一个地址，在那时候很出名的聊天室网站”碧海银沙”，那时候我觉得上网就是上这个网站聊天，这是我第一次接触到URL。&lt;br&gt;
    
    </summary>
    
      <category term="Node.js学习笔记" scheme="https://bennyzheng.github.io/categories/Node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Node.js" scheme="https://bennyzheng.github.io/tags/Node-js/"/>
    
      <category term="URL" scheme="https://bennyzheng.github.io/tags/URL/"/>
    
      <category term="Path" scheme="https://bennyzheng.github.io/tags/Path/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - path模块</title>
    <link href="https://bennyzheng.github.io/archivers/2016/11/node-path/"/>
    <id>https://bennyzheng.github.io/archivers/2016/11/node-path/</id>
    <published>2016-11-17T16:00:00.000Z</published>
    <updated>2016-11-24T14:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js提供了一组非常方便的API专门用来操作路径。不过当你翻开Node.js手册关于path模块的时候，开头那个大大的章节标题”<strong>Windows vs. POSIX</strong>“呈现在你的面前，不知道你是什么感觉？反正我是觉得蛋疼乳酸菊花紧，兼容问题到哪都逃不掉啊！<br> Win32以及类Unix的POSIX标准在路径上真心差距很大，这个只要玩过windows以及类Unix系统的人都知道，许多代码由于路径兼容问题直接无法跨平台使用。<br><a id="more"></a></p>
<h1 id="不同平台的路径差异"><a href="#不同平台的路径差异" class="headerlink" title="不同平台的路径差异"></a>不同平台的路径差异</h1><p>路径格式在大多数平台上都是POSIX标准格式，文件系统的根目录为/，然后各种设备（包括多个磁盘也一样）以它为根目录挂载为某个路径，因此任何目录在整个文件系统中的绝对路径都是一致的。</p>
<p>Windows与POSIX不同，它将磁盘分为多个区，它们并没有一个统一的根目录，比如C盘的根目录是C:\，D盘的根目录是D:\，如果你在D盘使用了/来代表根目录，那么它指的就是D:\。</p>
<p>Windows与POSIX在文件、目录名的命名上也略有不同，早期FAT16系统采用的是8.3命名方式，文件名最多8个字符，再加一个.以及最多3个字符的扩展名，比如”filename.ext”，后来win95开始才开始有了长文件名，但也是问题很多。不过我们现在基本上不需要关注短文件名以及长文件名，需要特别关注的是路径分隔符。在Windows的路径中分隔一个目录或文件的采用了\，而POSIX采用的是/，事实上Windows同样认识/分隔符（我宁愿它干脆不认识，净给人添麻烦）。</p>
<p>或许许多前端工程师没关注过什么叫POSIX，简单来说类Unix的系统（linux、BSD、OSX、Unix……）都是遵守POSIX规范的，这里引用一下百度百科对其做说明：</p>
<blockquote>
<p>POSIX表示可移植操作系统接口（Portable Operating System Interface ，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。<br>POSIX标准意在期望获得源代码级别的软件可移植性。换句话说，为一个POSIX兼容的操作系统编写的程序，应该可以在任何其它的POSIX操作系统（即使是来自另一个厂商）上编译执行。<br>POSIX 并不局限于 UNIX。许多其它的操作系统，例如 DEC OpenVMS 支持 POSIX 标准，尤其是 IEEE Std. 1003.1-1990（1995 年修订）或 POSIX.1，POSIX.1 提供了源代码级别的 C 语言应用编程接口（API）给操作系统的服务程序，例如读写文件。POSIX.1 已经被国际标准化组织（International Standards Organization，ISO）所接受，被命名为 ISO/IEC 9945-1:1990 标准。</p>
</blockquote>
<p>编写一个路径在POSIX和Windows下可以分别这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> winUrl = <span class="string">"d:\\wwwroot\\site\\file.ext"</span>;</div><div class="line"><span class="keyword">var</span> posixUrl = <span class="string">"/wwwroot/site/file.ext"</span>;</div></pre></td></tr></table></figure>
<p>posixUrl在windows下同样认识，但它的位置取决于file.ext文件在哪个分区，如果它在C盘，那么它就相当于”c:\wwwroot\site\file.ext”，如果在其它盘就得换盘符。</p>
<p>为了处理这类不同路径规范，path模块提供了两种实现：</p>
<ul>
<li>path.win32 - 强制使用windows的路径规范处理路径</li>
<li>path.posix - 强制使用posix的路径规范处理路径，根据我的实验，貌似这就是默认的处理方式。</li>
</ul>
<h1 id="path模块的方法"><a href="#path模块的方法" class="headerlink" title="path模块的方法"></a>path模块的方法</h1><p>Node.js的path模块针对上述路径差异也提供了相应的API或属性，个人认为，尽可能不要使用windows的路径写法。</p>
<h2 id="path-basename-path-ext"><a href="#path-basename-path-ext" class="headerlink" title="path.basename(path[, ext])"></a>path.basename(path[, ext])</h2><p>basename函数可以把路径最后一部份的名字返回，同时你如果使用了扩展名参数，它将自动将扩展名去掉，仅返回文件名（如果最后一部份是文件名的话）。</p>
<p>这里需要注意的是路径最后一部份是否必须是文件，如果是目录怎么办？请看示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="string">"/wwwroot/site/myfile.js"</span>;</div><div class="line"></div><div class="line"><span class="comment">// myfile.js</span></div><div class="line"><span class="built_in">console</span>.log(path.basename(url));</div><div class="line"></div><div class="line"><span class="comment">// myfile，要特别注意的是：扩展名包含这个"."，如果仅传"js"的话，将得到"myfile."！</span></div><div class="line"><span class="built_in">console</span>.log(path.basename(url, <span class="string">".js"</span>));</div><div class="line"></div><div class="line"><span class="comment">// myfile到底是目录还是文件？</span></div><div class="line">url = <span class="string">"/wwwroot/site/myfile"</span>;</div><div class="line"></div><div class="line"><span class="comment">// myfile，可见在这种情况下，它确实不在乎</span></div><div class="line"><span class="built_in">console</span>.log(path.basename(url));</div><div class="line"></div><div class="line"><span class="comment">// 如果路径最后一部份还带了个/呢？</span></div><div class="line">url = <span class="string">"/wwwroot/site/myfile/"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 同样是myfile！这点要特别注意！</span></div><div class="line"><span class="built_in">console</span>.log(path.basename(url));</div></pre></td></tr></table></figure>
<p>之前提到过windows以及POSIX的区别，那么如果路径是一个windows路径，它又是如何工作的？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">"E:\\wwwroot\\mysite\\myfile.js"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将得到 E:\wwwroot\mysite\myfile.js</span></div><div class="line"><span class="built_in">console</span>.log(path.basename(url));</div></pre></td></tr></table></figure>
<p>从运行结果可见，API默认是使用了POSIX，这也难怪，微软本来就是喜欢出一些东西自己玩，不受人待见很正常，但如果你确认你的路径是windows的路径格式，可以使用path.win32提供的同名API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">"E:\\wwwroot\\mysite\\myfile.js"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将得到 myfile.js</span></div><div class="line"><span class="built_in">console</span>.log(path.win32.basename(url));</div></pre></td></tr></table></figure>
<h2 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path)"></a>path.dirname(path)</h2><p>获取指定路径的目录名，它默认将basename当成文件名处理，也就是获取除了路径最后一部份之前的那一段路径。</p>
<p>与basename有个同样的疑问，如果路径最后一个字符是/，也就是路径最后一部份其实也是目录名，那又该怎么样?继续试验：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="string">"/wwwroot/site/myfile.js"</span>;</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot/site 没什么奇怪的，唯一要注意的是最后不带/</span></div><div class="line"><span class="built_in">console</span>.log(path.dirname(url));</div><div class="line"></div><div class="line"><span class="comment">// 看看没扩展名的情况</span></div><div class="line">url = <span class="string">"/wwwroot/site/myfile"</span>;</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot/site 它不在乎你有没有扩展名</span></div><div class="line"><span class="built_in">console</span>.log(path.dirname(url));</div><div class="line"></div><div class="line"><span class="comment">// 看看site本身也是目录的情况</span></div><div class="line">url = <span class="string">"/wwwroot/site/"</span>;</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot 看来它不在乎最后是不是文件，如果最后一段是目录名，那么它就获取该目录所在的目录路径。</span></div><div class="line"><span class="built_in">console</span>.log(path.dirname(url));</div></pre></td></tr></table></figure>
<h2 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname(path)"></a>path.extname(path)</h2><p>获取路径的扩展名。</p>
<p>关于扩展名，其实在类Unix系统中，扩展名并不重要，比如你给一个文件加上可执行权限，那么它就会被认为是一个应用程序。如果你用GUI界面操作系统，扩展名的主要工作用于确定mime-type（当然可以造假），然后决定用什么应用程序来打开这个文件。</p>
<p>扩展名是文件名后半部份，它的内容包含”.”，比如myfile.txt的扩展名是”.txt”。</p>
<p>官方给的例子挺详细，直接上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">path.extname(<span class="string">'index.html'</span>)</div><div class="line"><span class="comment">// returns '.html'</span></div><div class="line"></div><div class="line">path.extname(<span class="string">'index.coffee.md'</span>)</div><div class="line"><span class="comment">// returns '.md'</span></div><div class="line"></div><div class="line">path.extname(<span class="string">'index.'</span>)</div><div class="line"><span class="comment">// returns '.'</span></div><div class="line"></div><div class="line">path.extname(<span class="string">'index'</span>)</div><div class="line"><span class="comment">// returns ''</span></div><div class="line"></div><div class="line">path.extname(<span class="string">'.index'</span>)</div><div class="line"><span class="comment">// returns '' 这个要特别注意一下！扩展名可以没有，但文件名不能省。</span></div></pre></td></tr></table></figure>
<p>很幸福的，这个函数在windows系统下表现与POSIX一致。</p>
<h2 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject)"></a>path.format(pathObject)</h2><p>格式化一个pathObject，将其转成一个合法的字符串。pathObject可以拥有以下属性：</p>
<ul>
<li>dir - 目录路径，这个路径最后不要带有/，否则会出现使用//来分隔目录的情况</li>
<li>root - 根目录</li>
<li>base - 文件名+扩展名</li>
<li>name - 文件名</li>
<li>ext - 扩展名</li>
</ul>
<p>从手册描述上来看，格式化函数其实是个很弱智的函数，它仅仅是按一个简单的规则将这个pathObject定义的各个属性拼装起来成为一个字符串罢了，基本上遵守以下规则：</p>
<ul>
<li>path分为两个部份，一个是路径，对应dir以及root。一个是文件名，对应base、name以及ext。</li>
<li>dir/root是互斥的，如果dir存在，则不会管root，路径部份以dir为准。</li>
<li>base与name+ext是互斥的，如果base存在，则无视name以及ext，以base为准，也就是说base等于name+ext。</li>
</ul>
<p>为了更好的了解这个规则，继续上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 文件名为file.txt，dir和root同时存在</span></div><div class="line"><span class="keyword">var</span> pathObject = &#123;</div><div class="line">    <span class="attr">dir</span>: <span class="string">"."</span>,</div><div class="line">    <span class="attr">root</span>: <span class="string">"/"</span>,</div><div class="line">    <span class="attr">base</span>: <span class="string">"file.txt"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ./file.txt root被无视，结果等于dir + "/" + base</span></div><div class="line"><span class="built_in">console</span>.log(path.format(pathObject));</div><div class="line"></div><div class="line"><span class="comment">// 文件名为file.txt，只存在root</span></div><div class="line">pathObject = &#123;</div><div class="line">    <span class="attr">root</span>: <span class="string">"/"</span>,</div><div class="line">    <span class="attr">base</span>: <span class="string">"file.txt"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// /file.txt 结果等于root + base</span></div><div class="line"><span class="built_in">console</span>.log(path.format(pathObject));</div><div class="line"></div><div class="line"><span class="comment">// 这里引出了一个疑问，根据上一次输出的结果，</span></div><div class="line"><span class="comment">// format不会给root和base之间添加/，那么如果root不是/，并且不以/结束会怎么样?</span></div><div class="line"><span class="comment">// 文件名为file.txt，只存在root，并且值为/wwwroot，它不以/结束</span></div><div class="line">pathObject = &#123;</div><div class="line">    <span class="attr">root</span>: <span class="string">"/wwwroot"</span>,</div><div class="line">    <span class="attr">base</span>: <span class="string">"file.txt"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// /wwwrootfile.txt 囧啊，结果真的等于root + base，我早说它不智能了</span></div><div class="line"><span class="built_in">console</span>.log(path.format(pathObject));</div><div class="line"></div><div class="line"><span class="comment">// 同样，dir注明它被添到结果时，会在后边跟一个/隔开文件名</span></div><div class="line"><span class="comment">// 文件名为file.txt，只存在dir，并且值以/结尾</span></div><div class="line">pathObject = &#123;</div><div class="line">    <span class="attr">dir</span>: <span class="string">"/wwwroot/"</span>,</div><div class="line">    <span class="attr">base</span>: <span class="string">"file.txt"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot//file.txt 只能微笑一下了</span></div><div class="line"><span class="built_in">console</span>.log(path.format(pathObject));</div><div class="line"></div><div class="line"><span class="comment">// 我们如果故意把base的值瞎搞，它不是一个文件名，而是一段路径，会怎么样？</span></div><div class="line"><span class="comment">// 文件名为/dir/file.txt，root为/wwwroot，我怀疑结果将是/wwwroot/dir/file.txt</span></div><div class="line">pathObject = &#123;</div><div class="line">    <span class="attr">root</span>: <span class="string">"/wwwroot"</span>,</div><div class="line">    <span class="attr">base</span>: <span class="string">"/dir/file.txt"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot/dir/file.txt 如我所料</span></div><div class="line"><span class="built_in">console</span>.log(path.format(pathObject));</div><div class="line"></div><div class="line"><span class="comment">// 如果dir存在相对路径呢？比如/wwwroot/dir/..相当于/wwwroot，那么是否会处理？</span></div><div class="line">pathObject = &#123;</div><div class="line">    <span class="attr">dir</span>: <span class="string">"/wwwroot/dir/.."</span>,</div><div class="line">    <span class="attr">base</span>: <span class="string">"file.txt"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot/dir/../file.txt 真的仅仅是拼接一下，其实这事我也能干啊</span></div><div class="line"><span class="built_in">console</span>.log(path.format(pathObject));</div><div class="line"></div><div class="line"><span class="comment">// base与name和ext同时存在的情况</span></div><div class="line">pathObject = &#123;</div><div class="line">    <span class="attr">dir</span>: <span class="string">"/wwwroot"</span>,</div><div class="line">    <span class="attr">base</span>: <span class="string">"file.txt"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"myfile"</span>,</div><div class="line">    <span class="attr">ext</span>: <span class="string">".js"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot/file.txt 以base为准，name和ext被无视掉了，其它规则跟dir/root一样狗血。</span></div><div class="line"><span class="built_in">console</span>.log(path.format(pathObject));</div></pre></td></tr></table></figure>
<p>虽然path.format是如此弱智，但还是有办法补救的，我们还有一个path.normalize可以用来对它做处理。</p>
<h2 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute(path)"></a>path.isAbsolute(path)</h2><p>判断路径是否为绝对路径，这里同样存在兼容问题，由于API默认以POSIX标准为准，因此如果路径是一个windows规范路径，那么需要使用path.win32.isAbsolute来做判断，所以千万不要随便使用windows规范的路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"></div><div class="line"><span class="comment">// POSIX</span></div><div class="line"><span class="keyword">var</span> url = <span class="string">"/wwwroot/dir"</span>;</div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(url));</div><div class="line"></div><div class="line"><span class="comment">// WIN</span></div><div class="line">url = <span class="string">"E:\\wwwroot"</span>;</div><div class="line"><span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(path.isAbsolute(url));</div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(path.win32.isAbsolute(url));</div></pre></td></tr></table></figure>
<h2 id="path-join-…paths"><a href="#path-join-…paths" class="headerlink" title="path.join([…paths])"></a>path.join([…paths])</h2><p>将多个路径连接在一起，它相对于path.format来说非常智能，你不用担心它生成的路径会出现”//“，也不用担心各种弱智的表现，唯一要考虑的是你输入的路径应该是个字符串。</p>
<p>没什么特别注意的，只需要知道它很智能，能够识别.以及..之类的相对路径，并且把它们拼装成一个很好的路径即可。这是来自官方手册的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">path.join(<span class="string">'/foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz/asdf'</span>, <span class="string">'quux'</span>, <span class="string">'..'</span>)</div><div class="line"><span class="comment">// returns '/foo/bar/baz/asdf'</span></div><div class="line"></div><div class="line">path.join(<span class="string">'foo'</span>, &#123;&#125;, <span class="string">'bar'</span>)</div><div class="line"><span class="comment">// throws TypeError: Arguments to path.join must be strings</span></div></pre></td></tr></table></figure>
<h2 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize(path)"></a>path.normalize(path)</h2><p>在体验过path.format之后，我们需要一个函数对它生成的可能乱七八糟的路径做整理，使其变成一个很规范没有冗余字符的路径，path.normalize就是一个很好的选择。它能够识别.以及..，同时也能够帮你去除多余的/，有点不足的是它不识别windows路径分隔符\。</p>
<p>如果你使用的是win32的normalize，它将会把所有的/转化成\。建议在做处理之前先手工做一下替换，将\统一转成/。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 乱七八糟的路径</span></div><div class="line"><span class="keyword">var</span> url = <span class="string">"/wwwroot\\dir0/dir1//.././myfile.txt"</span>;</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot\dir0/myfile.txt</span></div><div class="line"><span class="built_in">console</span>.log(path.normalize(url));</div><div class="line"></div><div class="line"><span class="comment">// \wwwroot\dir0\myfile.txt</span></div><div class="line"><span class="built_in">console</span>.log(path.win32.normalize(url));</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot/dir0/myfile.txt 正解！</span></div><div class="line"><span class="built_in">console</span>.log(path.normalize(url.replace(<span class="regexp">/\\/g</span>, <span class="string">"/"</span>)));</div></pre></td></tr></table></figure>
<h2 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse(path)"></a>path.parse(path)</h2><p>将一个合法路径解析成一个pathObject，格式参考format函数。<br>这个方法同样不怎么智能，建议使用它的时候先做一下处理（请参考path.normalize示例代码）。</p>
<p>下面来看看它工作表现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 乱七八糟的路径</span></div><div class="line"><span class="keyword">var</span> url = <span class="string">"/wwwroot\\dir0/dir1//.././myfile.txt"</span>;</div><div class="line"></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//     root: '/',</span></div><div class="line"><span class="comment">//     dir: '/wwwroot\\dir0/dir1//../.',</span></div><div class="line"><span class="comment">//     base: 'myfile.txt',</span></div><div class="line"><span class="comment">//     ext: '.txt',</span></div><div class="line"><span class="comment">//     name: 'myfile'</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="built_in">console</span>.log(path.parse(url));</div><div class="line"></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//     root: '/',</span></div><div class="line"><span class="comment">//     dir: '/wwwroot\\dir0/dir1//../.',</span></div><div class="line"><span class="comment">//     base: 'myfile.txt',</span></div><div class="line"><span class="comment">//     ext: '.txt',</span></div><div class="line"><span class="comment">//     name: 'myfile'</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="built_in">console</span>.log(path.win32.parse(url));</div><div class="line"></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//     root: '/',</span></div><div class="line"><span class="comment">//     dir: '/wwwroot/dir0/dir1//../.',</span></div><div class="line"><span class="comment">//     base: 'myfile.txt',</span></div><div class="line"><span class="comment">//     ext: '.txt',</span></div><div class="line"><span class="comment">//     name: 'myfile'</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="built_in">console</span>.log(path.parse(url.replace(<span class="regexp">/\\/g</span>, <span class="string">"/"</span>)));</div><div class="line"></div><div class="line"><span class="comment">// 正解！</span></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//     root: '/',</span></div><div class="line"><span class="comment">//     dir: '/wwwroot/dir0',</span></div><div class="line"><span class="comment">//     base: 'myfile.txt',</span></div><div class="line"><span class="comment">//     ext: '.txt',</span></div><div class="line"><span class="comment">//     name: 'myfile'</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="built_in">console</span>.log(path.parse(path.normalize(url.replace(<span class="regexp">/\\/g</span>, <span class="string">"/"</span>))));</div></pre></td></tr></table></figure>
<h2 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative(from, to)"></a>path.relative(from, to)</h2><p>获取to参数相对于from参数的相对路径。</p>
<p>这个函数没什么特别好注意的，只需要注意它同样有windows的兼容性问题即可。</p>
<p>以下是官方示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">path.relative(<span class="string">'/data/orandea/test/aaa'</span>, <span class="string">'/data/orandea/impl/bbb'</span>)</div><div class="line"><span class="comment">// returns '../../impl/bbb'</span></div></pre></td></tr></table></figure>
<h2 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h2><p>这个函数与path.join非常相似，但它将会得到一个绝对路径，并且该路径是基于磁盘文件系统的，得到的结果与当前工作目录有关。</p>
<p>假设我当前工作目录在/wwwroot/github/bennyzheng.github.io/_posts/2016/（是真的……我的测试脚本就放在这个目录），那么以下代码将会得到相应的结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</div><div class="line"></div><div class="line"><span class="comment">// /wwwroot/github/bennyzheng.github.io/_posts/2016/myfile</span></div><div class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">"./"</span>, <span class="string">"myfile"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 注意第二个参数是以/开头，前边的./dir直接被无视掉了，因为它这里已经直接确定好根目录了</span></div><div class="line"><span class="comment">// /myfile</span></div><div class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">"./dir"</span>, <span class="string">"/myfile"</span>));</div></pre></td></tr></table></figure>
<h1 id="path模块的属性"><a href="#path模块的属性" class="headerlink" title="path模块的属性"></a>path模块的属性</h1><h2 id="path-delimiter"><a href="#path-delimiter" class="headerlink" title="path.delimiter"></a>path.delimiter</h2><p>保存了当前系统下多个路径的分隔符，它的值在windows系统下是;，在POSIX规范的系统下是:。<br>如果不理解，请查看当前系统的系统变量PATH的值，它就是多个路径连接在一起的。</p>
<p>上一下官方手册的示例代码，它演示了如何利用该属性将系统变量PATH分隔成多个路径，示例中的PATH变量明显是POSIX风格：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(process.env.PATH)</div><div class="line"><span class="comment">// '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'</span></div><div class="line"></div><div class="line">process.env.PATH.split(path.delimiter)</div><div class="line"><span class="comment">// returns ['/usr/bin', '/bin', '/usr/sbin', '/sbin', '/usr/local/bin']</span></div></pre></td></tr></table></figure>
<h2 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h2><p>保存了当前系统下使用的目录分隔符，它的值在windows下是\，在POSIX规范的系统下是/。</p>
<h2 id="path-posix"><a href="#path-posix" class="headerlink" title="path.posix"></a>path.posix</h2><p>提供了一套针对遵守posix规范的系统的API支持，从目前的试验来看，我们完全可以使用path.xxx来调用API，因为path.posix就是默认的方式。</p>
<h2 id="path-win32"><a href="#path-win32" class="headerlink" title="path.win32"></a>path.win32</h2><p>提供了一套针对windows系统的API支持，考虑到可移植性，强烈建议不要在你的程序中使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js提供了一组非常方便的API专门用来操作路径。不过当你翻开Node.js手册关于path模块的时候，开头那个大大的章节标题”&lt;strong&gt;Windows vs. POSIX&lt;/strong&gt;“呈现在你的面前，不知道你是什么感觉？反正我是觉得蛋疼乳酸菊花紧，兼容问题到哪都逃不掉啊！&lt;br&gt; Win32以及类Unix的POSIX标准在路径上真心差距很大，这个只要玩过windows以及类Unix系统的人都知道，许多代码由于路径兼容问题直接无法跨平台使用。&lt;br&gt;
    
    </summary>
    
      <category term="Node.js学习笔记" scheme="https://bennyzheng.github.io/categories/Node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Node.js" scheme="https://bennyzheng.github.io/tags/Node-js/"/>
    
      <category term="URL" scheme="https://bennyzheng.github.io/tags/URL/"/>
    
      <category term="Path" scheme="https://bennyzheng.github.io/tags/Path/"/>
    
  </entry>
  
  <entry>
    <title>Node.js - 探索数据流</title>
    <link href="https://bennyzheng.github.io/archivers/2016/11/explore-data-stream/"/>
    <id>https://bennyzheng.github.io/archivers/2016/11/explore-data-stream/</id>
    <published>2016-11-15T16:00:00.000Z</published>
    <updated>2016-11-24T14:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期一位同事问起数据流方面的问题，在做前端开发时很少直接面对数据流，只有在做node.js相关的东西会接触得比较多。我当时简单做了一些解答，但我认为我解答得不是很好，至少她还是一脸的迷茫。于是我准备在这里试着讲清数据流的来龙去脉。<br><a id="more"></a></p>
<h1 id="认识数据流"><a href="#认识数据流" class="headerlink" title="认识数据流"></a>认识数据流</h1><p>数据流是数据操作的抽象，它以统一的API、高效的内部实现让数据操作者很方便地操作多种设备上的数据，简单一点可以把数据流当成一组操作数据的API。</p>
<p>数据流并不是一个新概念，Unix系统将很多硬件设备挂载成设备文件，然后提供了一组低级I/O API用于数据交换，如果学过C语言那么这组API肯定会非常熟悉，许多数据(不仅仅是磁盘文件)的读写都可以用它们来做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ...)</span></span>;</div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fildes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte);</div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fildes, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fildes)</span></span>;</div></pre></td></tr></table></figure>
<p>可以看出Unix在数据读写方面已经考虑到了API的统一，这组I/O API被称为低级I/O，它们直接使用了系统调用来直接访问硬件进行数据读写，而且还不带缓冲区，这意味着每次调用都将读写一次设备，频繁的读写不仅存在性能问题还会影响到设备的寿命，大家在写C程序的时候一般使用的是标准I/O API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> filename, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> mode)</span></span>;</div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nitems, FILE *<span class="keyword">restrict</span> stream);</div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nitems, FILE *<span class="keyword">restrict</span> stream);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</div></pre></td></tr></table></figure>
<p>标准I/O的底层实现依然是调用了低级I/O，并且在低级I/O上再做了一层封装，实现了缓冲区，允许数据预读、缓写等缓冲功能，减少了与设备打交道的次数，也提高了性能。<br>请注意标准I/O的原型声明，FILE *类型的变量被命名为stream。由于C不是面向对象的，File *stream代表着数据，加上配套的标准I/O共同组成了数据流。<strong>数据流对原始数据操作做了一层封装，使其更合理、高效并且拥有了统一的API</strong>。</p>
<h1 id="数据流的使用"><a href="#数据流的使用" class="headerlink" title="数据流的使用"></a>数据流的使用</h1><p>Java语言给流抽象了四种类型:</p>
<ul>
<li>InputStream - 二进制输入流，应用程序可以使用该流从某个数据设备读取二进制数据</li>
<li>OutputStream - 二进制输出流，应用程序可以使用它往某个数据设备写入二进制数据</li>
<li>Reader - 字符输入流，与InputStream不同的是它操作的是字符串</li>
<li>Writer - 字符输出流，与OutputStream不同的是它写入的是字符串</li>
</ul>
<p>事实上，Reader和Write看起来更像是InputStream、OutputStream的一种封装，二者仅仅操作的是数据类型不一样，字符串也同样是二进制的。</p>
<p>而我们熟悉的Node.js同样给流抽象了四种类型：</p>
<ul>
<li>Readable - 拥有读能力的数据流</li>
<li>Writable - 拥有写能力的数据流</li>
<li>Duplex - 双向流，是Readable以及Writable的合体</li>
<li>Transform - 对Duplex的封装，允许写入数据后对数据做修改，重新读出来的数据将是修改后的数据</li>
</ul>
<p><em>从Java以及Node.js对流的定义上来看，数据流并没有一个固定的形式，但不外乎用于读和写，并且根据实际场景流可以同时拥有读和写的功能。数据流将数据使用者与数据设备隔离开来，数据使用者不需要关心数据设备接口是如何工作的，只需要调用数据流提供的统一的API即可完成操作。</em></p>
<p>对于一名前端工程师来说弄懂Node.js的数据流帮助更大，以下就以Node.js的数据流来做一些实验。</p>
<h2 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h2><p>fs模块提供了文件读写功能，其中有一个方法readFileSync非常方便，它可以一次性把文件内容返回给应用程序，示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> content = fs.readFileSync(<span class="string">"./test.js"</span>, &#123;</div><div class="line">    <span class="string">"encoding"</span>: <span class="string">"utf-8"</span>,</div><div class="line">    <span class="string">"flag"</span>: <span class="string">"r"</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(content);</div></pre></td></tr></table></figure>
<p>看起来非常方便，但对于小文件可以这样，对于大文件（比如动不动就上G的视频文件）如果还这么做分分钟内存溢出。</p>
<p>换种做法可以解决这种问题，比如使用fs.open/fs.read，但使用数据流是最简单的方法。</p>
<p>Readable以及其它数据流是以事件驱动来与应用程序互动的，它提供了以下几个事件：</p>
<ul>
<li>close - 流关闭时分发close事件，当一个流被关闭之后就不再生产数据，即变成不可读状态。手册中提示并不是所有的只读流都会分发该事件，它没有任何参数。</li>
<li>data - 在缓冲区有数据时分发data事件，拥有一个chunk参数。当data事件分发时，chunk参数默认会得到一个<buffer>对象，如果数据源提供的是字符串数据，则可以通过setEncoding函数设置文本编码，这时候chunk将会是一个字符串。</buffer></li>
<li>end - 当数据源不再生产数据时（比如磁盘文件读到结尾）分布本事件。</li>
<li>error - 当操作发生错误时触发。</li>
<li>readable - 当缓冲区有数据时分发readable事件，但需要主动调用read([size])函数读取数据。</li>
</ul>
<p>除了事件还提供了以下方法：</p>
<ul>
<li>isPaused - 检测流是否处于暂停状态，只有显式调用了pause方法才会让流转入暂停状态，不再从数据源读取数据。</li>
<li>pause - 显式要求流转入暂停状态，在暂停状态下不再从数据源读取数据，也不会触发data、readable事件。</li>
<li>pipe - 非常重要的方法，它能够传入一个允许写入的流（除了Readable，其它流都允许写入）当作流数据的目的地，成为一个管道。Readable将会自动读取数据，并且将它写入Writable流中。</li>
<li>read - 主动从数据缓冲区读取数据，可以显式传入size参数要求读多少字节，如果不传则是读取缓冲区全部数据。</li>
<li>resume - 显式要求流从暂停状态转入流动状态。</li>
<li>setEncoding - 如果确认数据源是字符串，那么可以使用setEncoding方法设置文本编码。要注意的是如果设置了文本编码，那么data事件的chunk参数或者read方法都将返回String而不是Buffer。</li>
<li>unpipe - 将管道断掉，pipe的反操作。</li>
<li>unshift - 将数据块重新塞回缓冲区，可以对数据块做修改。参考手册提示如果有这类需求应该考虑使用Transform流，个人觉得也确实如此，如果使用这个函数就失去了只读的意义了。</li>
<li>wrap - 允许传入一个旧数据流的实现，将它做为数据源使用新的流API读取。Node.js在之前有一套旧的流实现，这主要是做代码兼容之用。</li>
<li>push - 将数据添加到Readable的数据缓冲区，这个函数是为扩展Readable而实现的，除非你实现Readable的子类，否则它不应该被使用。</li>
</ul>
<p><em>一个刚打开的Readable流默认处于流动状态，调用isPaused函数可以看到值确实为false，但网上许多资料说刚打开的Readable是处于暂停状态，要绑定data、调用resume函数之类的操作才会让流进入流动状态。经过试验，在流刚打开时，stream._readableState.flowing的值为null，绑定data事件后会变成true，调用pause函数后变回false。也就是说相当于暂停状态，这么看就合理了，它确实不是暂停状态（值不是false），但也同时不是流动状态，但可以把这种默认状态当成暂停状态处理。</em></p>
<p>EventEmitter类是Node.js实现事件模型的基类，所有数据流都是它的子类，数据流的读操作也基本上是靠事件来工作。读操作一般是使用data+end或者readable+end事件来完成，或许在这里会有疑问为什么会提供了如此相似的两个事件。</p>
<p>data事件会将缓冲区第一个Buffer对象作为参数传给事件响应函数，如果使用了setEncoding方法设置了文本编码它将会将Buffer对象转成字符串作为参数，这是Readable主动取出数据交给响应函数。readable事件与data事件不同，readable仅仅是在数据缓冲区有数据可读时调用响应函数，然后由应用程序自己主动去调用read读取数据。</p>
<p>data事件以及pipe方法优先级会比readable事件更高，如果绑定了data事件或者调用pipe方法建立了数据管道，在这种情况下每次读取到数据的时候会触发data事件，但在所有数据都读取完之后会触发一次readable，并且调用read方法会得到null。</p>
<p>如果仅仅是将数据读到内存那么使用data事件妥妥的很方便，如果数据将会被写入到磁盘或者其它写入速度可能比读取速度慢的设备时则需要特别考虑到读写速度不同导致的问题，必须等到数据写完才能够读下一个缓冲区的数据。data事件可以将数据块chunk交给应用程序，应用程序得到chunk之后直接调用pause函数暂停流的读取，然后异步写入数据，在写完数据后再显式调用resume函数重新让流开始读取数据。而readable事件则可以由应用程序决定一次读多少数据到应用程序自己管理的缓冲区（其实就是内存中的一个变量），同样暂停流写入数据再恢复数据流的流动。也就是说readable看起来麻烦了一点，但灵活性更高，毕竟用户可以决定读多少数据。</p>
<p>以下是读取一个文件的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">"./test.js"</span>);</div><div class="line"><span class="keyword">var</span> content = <span class="string">""</span>;</div><div class="line"></div><div class="line">stream.setEncoding(<span class="string">"utf-8"</span>);</div><div class="line">stream.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">    content += chunk;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">stream.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"content"</span>);</div><div class="line">    stream.close();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在该例子中，首先使用了setEncoding设置该文件为文本文件，并且编码是utf-8。data事件不断触发，将数据追加到内存中，在end的时候关闭流，这是最普通的文件读取例子。</p>
<p>同样，可以使用readable来实现同样的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">"./test.js"</span>);</div><div class="line"><span class="keyword">var</span> content = <span class="string">""</span>;</div><div class="line"></div><div class="line">stream.setEncoding(<span class="string">"utf-8"</span>);</div><div class="line">stream.on(<span class="string">"readable"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buffer = <span class="keyword">this</span>.read();</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (buffer != <span class="literal">null</span>) &#123;</div><div class="line">        content += buffer;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">stream.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(content);</div><div class="line">    stream.close();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里要特别注意一点，readable在读到文件结尾的时候，还会触发一次，并且调用read函数读到的数据为null，所以要判断一下。在手册中特别提到，read函数应该仅在流处于暂停状态下才被调用，但在上边的示例中并没有显式调用pause方法将流暂停，流的状态值默认是null。如果手动在绑定readable事件之前调用resume，那么在事件响应中调用read方法将会得到null值，因为读取的数据块已经通过data事件分发出去了，哪怕你没监听data事件。</p>
<p>在以下示例中读取一个简单的js文件，read方法将得到null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">"./test.js"</span>);</div><div class="line"></div><div class="line">stream.setEncoding(<span class="string">"utf-8"</span>);</div><div class="line">stream.resume();</div><div class="line"></div><div class="line">stream.on(<span class="string">"readable"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// false true null</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.isPaused(), <span class="keyword">this</span>._readableState.flowing, <span class="keyword">this</span>.read());</div><div class="line">&#125;);</div><div class="line"></div><div class="line">stream.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    stream.close();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>之前提到过写的速度没有读的速度快时，我们需要对Readable流读取的速度进行限制，由于尚未讲到Writable流，因此直接使用fs.appendFile来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">"./test.js"</span>);</div><div class="line"></div><div class="line">stream.setEncoding(<span class="string">"utf-8"</span>);</div><div class="line">stream.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">    stream.pause();</div><div class="line"></div><div class="line">    fs.appendFile(<span class="string">"./test.dist.js"</span>, chunk, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        stream.resume();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">stream.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    stream.close();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>fs.appendFile是个异步操作，在触发data事件的时候先让数据流暂停（这时候不再触发data事件），然后开始异步写数据，写完数据调用resume让数据流重新开始流动。</p>
<h2 id="Writable"><a href="#Writable" class="headerlink" title="Writable"></a>Writable</h2><p>Writable流允许向一个数据设备写入数据，它拥有以下事件：</p>
<ul>
<li>close - 数据流关闭时触发，数据流关闭后就不能向其写入数据。</li>
<li>drain - 数据流缓冲区数据量达到高水位（highWaterMark）后需要暂停往Writable写入数据，Writable缓过劲来的时候将会触发本事件，通知外部可以继续往数据流里写数据。</li>
<li>error - 数据流写入数据失败或者其它错误时触发该事件。</li>
<li>finish - 当数据流被调用了end方法之后触发，这时候所有数据已经从缓冲区写入数据设备。</li>
<li>pipe - 如果本Writable流被当成参数传入某个Readable流作为数据管道的下游时，Readable往Writable写入数据时将会触发本事件，表示管道有数据流入。</li>
<li>unpipe - Readable断开与Writable的管道关系时触发</li>
</ul>
<p>以下是Writable提供的方法</p>
<ul>
<li>cork - 塞住数据流与数据设备的数据交换，这时候所有写入Writable的数据将被存放到缓冲区，除非调用了uncork或者end方法才会将缓冲区的数据写入数据设备。</li>
<li>end - 要求数据流清空缓冲区，将所有数据全部写入数据设备。调用该方法后就不允许再使用write方法写入数据。</li>
<li>setDefaultEncoding - 当数据来源是文本数据时可以为其设置一个默认的编码，如果没有设备过则表示数据是Buffer形式。</li>
<li>uncork - cork的反操作，允许数据流重新开始将保存在缓冲区的数据写入数据设备。</li>
<li>write - 往数据流写入数据，数据可能会马上被写入数据设备，也可能保存到缓冲区</li>
</ul>
<p>Writable跟Readable在使用上略有不同，Readable基本上通过监听data或readable事件来被动获取数据，而Writable则是反过来被动地被调用write方法写入数据。</p>
<p>一个最简单的写数据例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> stream = fs.createWriteStream(<span class="string">"./test.dist.js"</span>);</div><div class="line"></div><div class="line">stream.setDefaultEncoding(<span class="string">"utf-8"</span>);</div><div class="line">stream.write(<span class="string">"hello world"</span>);</div><div class="line">stream.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    stream.close();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>外部向数据流写入数据的速度如果比数据流写入数据设备的速度快时，来不及写入的数据将会被放到缓冲区。缓冲区有一个名为高水位（highWaterMark）的限制，如果数据流是对象模式（二进制，数据以Buffer存放）则默认是16个Buffer对象，如果是文本模式（数据以String的形式存放）则默认是16kb。当超过缓冲区高水位时，写入的数据依然会被放到缓冲区，但这时候write方法将会返回false，通知写入者必须缓一缓了。暂停写入数据后，Writable会继续往数据设备写数据，在缓冲区的数据清空后将会分发drain事件，通知写入者可以继续调用write写数据。</p>
<p>使用drain事件可以将Readable中对应的例子简单改改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">"./test.js"</span>);</div><div class="line"><span class="keyword">var</span> wstream = fs.createWriteStream(<span class="string">"./test.dist.js"</span>);</div><div class="line"></div><div class="line">stream.setEncoding(<span class="string">"utf-8"</span>);</div><div class="line">wstream.setDefaultEncoding(<span class="string">"utf-8"</span>);</div><div class="line"></div><div class="line">stream.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!wstream.write(chunk)) &#123;</div><div class="line">        <span class="keyword">this</span>.pause();</div><div class="line">    &#125;    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">stream.on(<span class="string">"drain"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.resume();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">stream.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.close();</div><div class="line">    wstream.close();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>事实上还有更好的办法可以处理这种情况，比如直接使用Readable的pipe方法让Readable与Writable配对形成管道，Readable读出来的数据会直接写入Writable，同时它会处理好各种情况而不需要工程师自己操心，从这方面上看，pipe简直就是节省代码的神器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">"./test.js"</span>);</div><div class="line"><span class="keyword">var</span> wstream = fs.createWriteStream(<span class="string">"./test.dist.js"</span>);</div><div class="line"></div><div class="line">stream.setEncoding(<span class="string">"utf-8"</span>);</div><div class="line">wstream.setDefaultEncoding(<span class="string">"utf-8"</span>);</div><div class="line">stream.pipe(wstream);</div></pre></td></tr></table></figure>
<h2 id="Duplex-amp-Transform"><a href="#Duplex-amp-Transform" class="headerlink" title="Duplex &amp; Transform"></a>Duplex &amp; Transform</h2><p>看了Node.js关于双向流的手册，里边介绍非常简单，双向流是Readable和Writable的合体，也就是说我们可以把它当Readable使用也可以当Writable使用，二者有的事件与方法双向流也都有，因此在这里不再重复说明。</p>
<p>双向流要特别注意的一点就是：它既然是Readable和Writable的合体，因此它可以利用pipe形成一个管道链，最简单的就是对数据做压缩并且输出到一个文件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">"zlib"</span>);</div><div class="line"><span class="keyword">var</span> gz = zlib.createGzip();</div><div class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">"./test.js"</span>);</div><div class="line"><span class="keyword">var</span> wstream = fs.createWriteStream(<span class="string">"./test.js.gz"</span>);</div><div class="line"></div><div class="line">stream.setEncoding(<span class="string">"utf-8"</span>);</div><div class="line">stream.pipe(gz).pipe(wstream);</div></pre></td></tr></table></figure>
<p>示例中，gz对象是zlib创建的一个Transform流，它的工作就是外部写入数据，然后它对其做压缩处理后输出给wstream写入文件中，这种方式在gulp脚本中应用非常多。</p>
<h1 id="数据流的扩展"><a href="#数据流的扩展" class="headerlink" title="数据流的扩展"></a>数据流的扩展</h1><p>四种数据流都是基类，类似fs.createReadStream返回的数据流其实都是它们的子类。要实现自己的数据流，需要继承相应的数据流，并且实现关键方法：</p>
<ul>
<li>Readable: _read</li>
<li>Writable: _write, _writev</li>
<li>Duplex: _read, _write, _writev</li>
<li>Transform: _transform, _flush</li>
</ul>
<h2 id="Readable-1"><a href="#Readable-1" class="headerlink" title="Readable"></a>Readable</h2><p>Readable可以使用new Readable创建一个子类，并传入这些参数：</p>
<ul>
<li>highWaterMark - 缓冲区高水位限制，当读取的数据放入缓冲区后超过高水位则暂缓读入，直到缓冲区数据被外部读取消耗掉。</li>
<li>encoding - 如果数据源是文本数据，则可以传入编码，将数据流从默认的对象模式转为文本模式，使用read方法或者data事件得到的数据块将使用该编码解码，并且类型都将变成String。</li>
<li>objectMode - 是否使用对象模式，如果值为false则表示数据源是文本数据，将使用默认编码将Buffer转成String。</li>
<li>read - 实现私有方法_read，实现数据流自定义的数据读取方式，该方法由数据流本身调用，不需要考虑缓冲区的问题。</li>
</ul>
<p>以下是使用new Readable创建一个新的只读数据流的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</div><div class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">"stream"</span>).Readable;</div><div class="line"></div><div class="line"><span class="keyword">const</span> FileReadString = <span class="keyword">new</span> Readable(&#123;</div><div class="line">    <span class="attr">read</span>: <span class="function"><span class="keyword">function</span>(<span class="params">size</span>) </span>&#123;</div><div class="line">        <span class="comment">// 在这里实现读取数据的具体实现</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我个人认为使用new Readable方式创建子类的形式很不灵活，更倾向于使用Node.js用于做类型扩展的工具函数util.inherits创建它的了类，以只读文件为例实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</div><div class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">"stream"</span>).Readable;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FileReadStream</span>(<span class="params">path, options</span>) </span>&#123;</div><div class="line">    <span class="comment">// 必须调用基类的构造函数，将配置信息传进去</span></div><div class="line">    Readable.call(<span class="keyword">this</span>, options);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._path = path; <span class="comment">// 文件路径，为了省事，不考虑该文件不存在的情况</span></div><div class="line">    <span class="keyword">this</span>._offset = <span class="number">0</span>; <span class="comment">// 当前文件游标在文件中的位置</span></div><div class="line">    <span class="keyword">this</span>._fd = <span class="literal">null</span>; <span class="comment">// 文件描述符</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">util.inherits(FileReadStream, Readable);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 重写_read方法</div><div class="line">* 由于_read应该是一个同步操作，所以这里使用的都是同步API</div><div class="line">*/</div><div class="line">FileReadStream.prototype._read = <span class="function"><span class="keyword">function</span>(<span class="params">size</span>) </span>&#123;</div><div class="line">    <span class="comment">// 第一次使用时打开文件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._fd == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._fd = fs.openSync(<span class="keyword">this</span>._path, <span class="string">"r"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果不指定需要读多少数据，则默认读16kb。</span></div><div class="line">    size = size == <span class="literal">null</span> ? <span class="number">1024</span> * <span class="number">16</span> : size;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> buffer = Buffer.alloc(size);</div><div class="line">    <span class="keyword">var</span> len = fs.readSync(<span class="keyword">this</span>._fd, buffer, <span class="number">0</span>, size, <span class="keyword">this</span>._offset);</div><div class="line">    <span class="keyword">this</span>._offset += len;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 如果读不出数据则调用push(null)告诉数据流已经没有数据了</span></div><div class="line">        <span class="keyword">this</span>.push(<span class="literal">null</span>);</div><div class="line">        <span class="comment">// 关闭掉文件</span></div><div class="line">        fs.closeSync(<span class="keyword">this</span>._fd);</div><div class="line">        <span class="keyword">this</span>._fd = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 分发事件，告诉外部数据流已经关闭</span></div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">"close"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 将读取的二进制数据插入到缓冲区，是否转成文本那是Readable自己的事</span></div><div class="line">        <span class="keyword">this</span>.push(buffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> FileReadStream(<span class="string">"./test.js"</span>);</div><div class="line">stream.setEncoding(<span class="string">"utf-8"</span>);</div><div class="line"></div><div class="line">stream.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>除了这两个方法，还可以使用es6的extends来扩展，手册中有不再详说。</p>
<h2 id="Writable-1"><a href="#Writable-1" class="headerlink" title="Writable"></a>Writable</h2><p>创建一个Writable的子类可以传入以下参数：</p>
<ul>
<li>highWaterMark - 写缓冲区的高水位，如果写入的数据超出高水位的限制，那么Writable的write方法将会返回false通知外部需要暂停写入，当数据从缓冲区写入到数据设备后将会触发drain事件通知外部可以重新写入数据。</li>
<li>decodeStrings - 要求Writable在写入数据时是否先将Buffer以这里设置的编码转成字符串再调用_write方法。</li>
<li>objectMode - 是否启用对象模式，如果启用写入的数据将是一个Buffer。</li>
<li>_write - 将数据写到数据设备的具体实现。</li>
<li>_writev - 批量写入多个数据，它并不是必须实现的，但可以重写。它的参数跟_write相比（请看下方示例）少了一个encoding，而chunk则换成chunks（数组），每个元素是一个形式为{ chunk: …, encoding: …}的对象，默认是调用_write来完成工作，可以重写它来实现更高效的批量写入。</li>
</ul>
<p>具体细节不再讲解，以写一个磁盘文件为例实现一个FileWriteStream：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</div><div class="line"><span class="keyword">var</span> Writable = <span class="built_in">require</span>(<span class="string">"stream"</span>).Writable;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FileWriteStream</span>(<span class="params">path, options</span>) </span>&#123;</div><div class="line">    <span class="comment">// 必须调用基类的构造函数，将配置信息传进去</span></div><div class="line">    Writable.call(<span class="keyword">this</span>, options);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._path = path; <span class="comment">// 文件路径</span></div><div class="line">    <span class="keyword">this</span>._fd = <span class="literal">null</span>; <span class="comment">// 文件描述符</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">util.inherits(FileWriteStream, Writable);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * _write的实现，这里应该使用异步模式写入数据</div><div class="line"> * @param chunk 数据块，可能是一个Buffer也可能是一个String</div><div class="line"> * @param encoding 当chunk是一个String时，这里注明了它的编码</div><div class="line"> * @param callback 当写入操作完成时_write需要调用callback通知外部已经写完数据,如果写入发生异常也需要将Error对象传给callback</div><div class="line"> * @private</div><div class="line"> */</div><div class="line">FileWriteStream.prototype._write = <span class="function"><span class="keyword">function</span>(<span class="params">chunk, encoding, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> stream = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        fs.write(stream._fd, chunk, <span class="number">0</span>, chunk.length, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123;</div><div class="line">                callback(err);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            callback();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._fd == <span class="literal">null</span>) &#123;</div><div class="line">        fs.open(<span class="keyword">this</span>._path, <span class="string">"a"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123;</div><div class="line">                callback(err);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            stream._fd = fd;</div><div class="line"></div><div class="line">            stream.once(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                fs.closeSync(stream._fd);</div><div class="line">                stream._fd = <span class="literal">null</span>;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            write();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        write();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> FileWriteStream(<span class="string">"./test.txt"</span>);</div><div class="line">stream.write(<span class="string">"hello world"</span>);</div><div class="line">stream.end();</div></pre></td></tr></table></figure>
<p>从这里可以看出Readable跟Writable与数据设备交互的时候略有不同，前者必须用同步读取，因为数据必须马上返回给外部，而Writable则可以异步写数据，因为数据设备的写入速度不可预知，而外部数据是写到缓冲区中的。</p>
<h2 id="Duplex"><a href="#Duplex" class="headerlink" title="Duplex"></a>Duplex</h2><p>Duplex在手册中一直强调是Readable以及Writable的合体，非常经典的应用就是tcp socket。它的扩展方式是Readable以及Writable二者扩展方式的合并，不过在创建子类的时候参数略有不同，单独出现Duplex的原因是因为Javascript不支持多重继承（囧）。</p>
<ul>
<li>allowHalfOpen - 是否允许半打开状态，默认为真。Duplex流是双向流，因此跟外部的交互有读有写，如果设置为false，则当其中一个方式结束时自动关闭另一个，默认允许只关闭一端。</li>
<li>readableObjectMode - 当被作为可读流使用时是否使用对象模式</li>
<li>writableObjectMode - 当被作为可写流使用时是否使用对象模式</li>
<li>_read - 实现read方法</li>
<li>_write - 实现write方法</li>
<li>_writev - 实现批量写操作，可以不实现。</li>
</ul>
<p>这里不再对Duplex的实现做示例，因为仅仅是Readable和Writable实现的合并。</p>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>Transform是对Duplex的扩展，它的作用更多是用在数据的处理环节上，工程师调用Transform的write方法写入数据，然后Transform将数据交给_transform做处理，处理完后再写入read的缓冲区允许外部读取，gulp在这方面应用得特别多。</p>
<ul>
<li>_transform - 对写入的数据做处理，并重新塞回Readable缓冲区以供外部读取</li>
<li>_flush - 将Writable中残留的缓冲区数据交给_transform做处理，本方法可以不实现</li>
</ul>
<p>以下实现用于去除字符串空格的Transform示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</div><div class="line"><span class="keyword">var</span> Transform = <span class="built_in">require</span>(<span class="string">"stream"</span>).Transform;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringTransform</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">    Transform.call(<span class="keyword">this</span>, options);</div><div class="line">&#125;</div><div class="line"></div><div class="line">util.inherits(StringTransform, Transform);</div><div class="line"></div><div class="line">StringTransform.prototype._transform = <span class="function"><span class="keyword">function</span>(<span class="params">chunk, encoding, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = chunk.toString(<span class="string">"utf-8"</span>).replace(<span class="regexp">/\s/g</span>, <span class="string">""</span>);</div><div class="line">    <span class="keyword">this</span>.push(str);</div><div class="line">    callback();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">"这 可 是 一 段 文 字 "</span>;</div><div class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> StringTransform();</div><div class="line">stream.setEncoding(<span class="string">"utf-8"</span>);</div><div class="line"></div><div class="line">stream.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">stream.write(str);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期一位同事问起数据流方面的问题，在做前端开发时很少直接面对数据流，只有在做node.js相关的东西会接触得比较多。我当时简单做了一些解答，但我认为我解答得不是很好，至少她还是一脸的迷茫。于是我准备在这里试着讲清数据流的来龙去脉。&lt;br&gt;
    
    </summary>
    
      <category term="Node.js学习笔记" scheme="https://bennyzheng.github.io/categories/Node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Node.js" scheme="https://bennyzheng.github.io/tags/Node-js/"/>
    
      <category term="Binary" scheme="https://bennyzheng.github.io/tags/Binary/"/>
    
      <category term="Buffer" scheme="https://bennyzheng.github.io/tags/Buffer/"/>
    
      <category term="Stream" scheme="https://bennyzheng.github.io/tags/Stream/"/>
    
  </entry>
  
</feed>
